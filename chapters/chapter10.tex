\newpage
\chapter{Приближени пресмятания - подходи, методи, алгоритми}
\label{chapter10}
\thispagestyle{empty}

В изчислителната математика се открояват две основни направления – точните числени пресмятания и приближените числени пресмятания\index{приближени пресмятания}. Точни числени пресмятания\index{точни числени методи} се извършват в ситуации в които обемът на задачата позволява изчисленията да се осъществят в приемлив интервал от време. В реалната практика често поставяните задачи значително нарастват като обем и тяхното пресмятане с точени числени методи става неприемливо по отношение на нужното време за пресмятане. В такива ситуации се прибягва до множеството разработени методи за приближени пресмятания\index{приближени числени методи}. По отношение на програмния продукт R, ще бъдат разгледани някои от най-популярните методи за приближени числени пресмятания, а именно Монте-Карло симулации, генетични алгоритми и изкуствени невронни мрежи.

\section{Монте-Карло методи}

В средата на XX век, във връзка с разработването на първите ядрени оръжия, са разработени група методи за приближени пресмятания, които залагат на способ за генериране на голямо количество случайни числа и последващата им статистическа обработка. Монте-Карло методите\index{Монте-Карло методи} намират най-голямо приложение в оптимизационни задачи, числено интегриране и генериране на семпли за специфични вероятностни разпределения. Монте-Карло методите могат да се използват за решаването на всяка задача, която има представяне в термините на вероятности и статистика. 

Има вариации в реализацията на Монте-Карло методите, но те в общия случай следват няколко добре дефинирани стъпки:

1. Определяне на област от допустими стойности;

2. Генериране на извадка от случайни числа в предварително дефинираната област;

3. Извършване на точни пресмятания с така генерираните случайни числа;

4. Обобщаване на резултатите от извършените пресмятания.

\begin{figure}[h!]
  \centering
  \includegraphics[width=0.8\linewidth]{pic0060}
  \caption{Пресмятане на числото $\pi$ с Монте-Карло метод}
\label{figure0060}
\end{figure}
\FloatBarrier

Един от най-популярните примери за Монте-Карло пресмятане е приближеното изчисление на числото $\pi$ (Фиг. \ref{figure0060}). За тази цел една четвърт от окръжност се представя с обгръщащия я квадрат. Съотношението между площите на квадрата и на четвъртината окръжност е $\pi/4$. За да се апроксимира стойността на числото $\pi$ с Монте-Карло метод се изпълняват следните стъпки:

1. Изчертаване на квадрат и четвъртина окръжност вписана в него;

2. Генериране на случайни равномерно разпределени числа, като координати (x,y двойки) в описаната допустима област;

3. Изброяване на точките с координати x,y които са на разстояние 1 от центъра на четвърт окръжността; 

4. Съотношението между точките в четвърт окръжността и общия брой точки е $\pi/4$, което умножено по 4 дава приближена стойност за числото $\pi$. 

При тази процедура за приближено пресмятане е важно да се вземат под внимание два много важни фактора:

1. Ако генерираните случайни числа не са равномерно разпределени, това ще доведе до невярна апроксимация за търсената стойност;

2. Генерирането на малък брой координати за точки в дефиниционната област води до ниско надеждна стойност за апроксимация, което означава, че колкото по-голям обем е извадката от случайни числа, толкова по-надеждни резултати за апроксимация.

\begin{lstlisting}[caption=Монте-Карло пресмятане, label=listing0175]
library( MonteCarlo )

mode <- function(x) {
	values <- unique(x)
	return( values[which.max(tabulate(match(x, values)))] )
}

experiment <- function(n, d){
	x <- sample(6,n,TRUE)

	for(i in 2:d) {
		x <- x + sample(6,n,TRUE)
	}

	return( list("mean"=mean(x), "median"=median(x), "mode"=mode(x)) )
}

result <- MonteCarlo(func=experiment, nrep=1000, param_list=list("n"=c(10, 50, 100, 150, 200),"d"=c(1,2,6)))

summary( result );

MakeTable(output=result, rows=c("d"), cols=c("n","list"), digits=2, include_meta=FALSE)
\end{lstlisting}

Към програмния продукт R е създаден отделен пакет (автор Christian Hendrik Leschinski) за извършване на Монте-Карло пресмятания, наречен „MonteCarlo“ (Листинг \ref{listing0175}). 

За демонстрация на възможностите, които R дава при Монте-Карло симулации е представено сравнение между средната, медианата и модата за вероятностно разпределение на сумата от $n$ зара. Тъй като R не предлага функция за пресмятане на мода е необходимо тази функция да бъде предварително дефинирана (Листинг \ref{listing0175}).

В пакета $MonteCarlo$\index{Монте-Карло методи} основно се използват две функции - $MonteCarlo$ и $MakeTable$. Функцията $MonteCarlo$ има за основна задача генерирането на множеството експерименти в процеса на симулацията. Най-важният параметър за тази функция е функционален обект, който описва единичен експеримент. В програмния език R функционалните обекти по своята същност представляват потребителски дефинирани функции. В предложения пример функционалният обект се нарича $experiment$, а функцията която представлява получава два входни параметъра $n$ и $d$. Потребителят на пакета $MonteCarlo$ сам може да избира какъв брой параметри да има функцията за единичен експеримент. В настоящия пример $n$ определя броят случайни числа, които да бъдат генерирани (размер на случайната извадка), а $d$ определя колко зара ще участват във формирането на крайния резултат. При предишни примери бе показано, че вероятностното разпределение на един зар е равномерно, на два зара триъгълно, а при достатъчно много зарове разпределението клони към нормалното. В този пример се разглеждат разликите между средната, медианата и модата за 1, 2 и 6 зара.

Към функцията за единичен експеримент има следните изисквания: 1. Аргументите а бъдат скаларни стойности; 2. Върнатата стойност от функцията да бъде списък с именувани или неименувани скаларни стойности. Потребителската функция за единичен експеримент се изпълнява в текущото работно пространство и поради тази причина всички нужни библиотеки, променливи с данни и помощни функции трябва да са заредени предварително. 

Вторият важен аргумент на функцията $MonteCarlo$ е $param_list$ и трябва да изпълнява следните изисквания: 1. Трябва да е списъчна структура; 2. Елементите на списъка трябва да са именувани и имената да съответстват на имената използвани за параметри в потребителската функция за единичен експеримент; 3. Всеки елемент в списъка е вектор със скаларни стойности; 4. Списъкът съдържа точно толкова на брой елементи, колкото са параметрите на потребителската функция за единичен експеримент. 

Последният задължителен аргумент на функцията $MonteCarlo$ е $nrep$ и той определя колко пъти ще бъде изпълнен Монте-Карло експериментът. В представения пример (Листинг \ref{listing0175}) се изпълняват хиляда повторения за три възможни комбинации от зарове, при пет различни броя за хвърлянето на тези зарове, а именно 10, 50, 100, 150 и 200. 

\begin{table}[h]
\centering
\resizebox{ 1 \textwidth}{!}{%
\begin{tabular}{ rrrrrrrrrrrrrrrrrrr }
\hline\hline\\\\
 list && \multicolumn{ 5 }{c}{ mean } &  & \multicolumn{ 5 }{c}{ median } &  & \multicolumn{ 5 }{c}{ mode } \\ 
d/n &  & 10 & 50 & 100 & 150 & 200 &  & 10 & 50 & 100 & 150 & 200 &  & 10 & 50 & 100 & 150 & 200 \\ 
 &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  &  \\ 
1 &  & 10.50 & 10.48 & 10.49 & 10.50 & 10.50 &  & 10.52 & 10.50 & 10.48 & 10.50 & 10.52 &  & 10.48 & 10.50 & 10.42 & 10.49 & 10.53 \\ 
2 &  &  7.01 &  7.00 &  7.00 &  7.01 &  6.99 &  &  7.02 &  7.01 &  7.00 &  7.00 &  7.00 &  &  7.03 &  7.04 &  6.98 &  6.98 &  6.99 \\ 
6 &  & 20.94 & 21.03 & 21.00 & 21.01 & 21.00 &  & 20.90 & 21.01 & 20.99 & 21.00 & 21.00 &  & 20.86 & 20.98 & 21.04 & 21.00 & 20.97 \\ 
\\
\\
\hline\hline
\end{tabular}%
}
\caption{Сравнение на средна, медиана и мода за експеримент със зарове}
\label{table0005}
\end{table}

За визуализация на получените резултати от функцията $MonteCarlo$ се използва функцията $MakeTable$. На функцията $MakeTable$ се подава резултата от симулацията и тя генерира таблица с резултати в $LaTeX$ формат (Таб. \ref{table0005}).

Функцията $MakeTable$ дава множество възможности, но само три от аргументите й са задължителни. На аргумента $output$ се присвоява резултата от изпълнението на функцията $MonteCarlo$. Вторият и третият аргумент са $rows$ и $cols$, като те определят по какъв начин ще се организират табличните данни. В представения пример (Листинг \ref{listing0175}) по редове са организирани броя зарове участващи в единичен експеримент, а по колони са организирани броят хвърляния на заровете, групирани по вида статистика (средна, медиана или мода). 

Макар и незадължителен параметърът $digits$ е определен на 2, което дава по-добра прегледност на табличната визуализация. Също незадължителен параметърът $include_meta$ е установен на „лъжа“ с цел да не се генерират коментари с обобщаваща информация за извършената симулация. 

\section{Генетични алгоритми}

Генетичните алгоритми\index{генетични алторитми} са евристика за глобална оптимизация, която е вдъхновена от идеите за естествената природна еволюция. Генетичните алгоритми са спадат към по-голям клас оптимизационни евристики наречени „еволюционни алгоритми“\index{еволюционни алгоритми}. Основното си приложение генетичните алгоритми намират в оптимизационни задачи в големи пространства. По-своята същност генетичните алгоритми са вероятностни и генерират субоптимални решения, като относително рядко достигат до глобалния опитимум. Изчисленията при генетичните алгоритми са организирани в три основни операции (рекомбинация) – селекция, кръстосване и мутация. Пресмятанията най-често започват от група случайно генерирани решения, които съставят първоначалната популация. Целта е в процеса на еволюция решенията системно да се подобряват. Популацията условно се разделя на старо и ново поколение. В новото поколение влизат решенията генерирани след рекомбинацията. За всяко решение в популацията се определя стойност на жизнеспособност. В общия случай стойността на жизнеспособност е резултата от пресмятането на функцията, която подлежи на оптимизация. Най-жизнеспособните решения биват подбрани да участват в създаването на новото поколение. Създаването на нови поколения е итеративен процес и най-често той приключва след изтичането на определен брой поколения или достигане на задоволително ниво за оптималност на предложеното решение. 

Генетичните алгоритми представят информацията под формата на група от решения организирани в популация. Всяко решение представлява вектор от стойности в пространството на решенията. Кодирането на задачата в термините на генетичните алгоритми е строго специфично за всяка задача. При целочислени задачи стойностите във вектора са цели числа. При пресмятане на непрекъснати задачи стойностите на вектора са реални числа. При някои комбинаторни задачи кодирането е под формата на пермутации. В повечето случаи дължината на вектора е фиксирана, но това не е задължително условие. Примерно при кодиране на серия от инструкции за конкретна машина, дължината на серията може да варира. Най-често началната популация се генерира на случаен принцип, но това не е задължително, особено ако се налага оптимизацията да продължи от вече постигнати резултати. Съществен е въпросът за размера на популацията и в практиката се е наложило този размер да се определя експериментално. При селекцията е от значение най-жизнеспособните решения да имат най-голям шанс за възпроизвеждане, но в същото време е важно и по-слабите решения да има шанс за участие в следващото поколение. 

Оценката на жизнеността най-често се постига, чрез подаване на решението към целевата функция. Целевата функция е строго специфична за всяка различна задача, която се решава. Желателно е целевата функция да връща единствена стойност. Ако при оптимизационната задача има повече критерии за оптимизиране, то многокритериалната задача трябва да се сведе до еднокритериална. След избора на два (или повече) родители, операцията по кръстосване разменя части от векторите. С помощта на кръстосването се изследват обширни региони от пространството на решенията. При мутацията на случаен принцип в новото поколение се избират отделни елементи от вектора и те се модифицират. Мутацията спомага за изследването на близки околности във вече генерираните точки в пространството на решенията. 

Използването на генетични алгоритми става неефективно в ситуации в които целевата функция изисква неприемливо дълго време за пресмятане. Тъй като генетичните алгоритми ползват генерирането на голямо количество междинни решения, множеството пресмятания на целевата функция може да направи цялата оптимизация неприемливо бавна. Важно е също да се знае, че генетичните алгоритми не гарантират намирането на глобалния оптимум, най-вече когато този оптимум не е предварително известен. Генетичните алгоритми не са ефективни при задачи където целевата функция води само до две състояния „добро“ или „лошо“. За да бъде ефективен процесът по оптимизацията решенията в популацията трябва да подлежат на подреждане, спрямо тяхната жизнеспособност. 

\begin{table}[h!]
\centering
\begin{tabular}{|l|r|r|} 
  \rowcolor{lightgray}
  \hline
  Предмет & Ценност & Тегло \\ [0.1ex] 
  \hline\hline
  cake & 10 & 1 \\
  \hline
  ice cream & 15 & 10 \\
  \hline
  orange juice & 10 & 5 \\
  \hline
  strawberries & 30 & 7 \\
  \hline
  grape & 30 & 1 \\
  \hline
  candies & 20 & 5 \\
  \hline
  chocolate & 2 & 1 \\
  \hline
\end{tabular}
\caption{Предмети с определена ценност и тегло}
\label{table0006}
\end{table}

\begin{lstlisting}[caption=Оптимизация на задачата за раницата с генетични алгоритми, label=listing0176]
library(genalg)

data <- data.frame(item = c("cake", "ice cream", "orange juice", "strawberries", "grape", "candies", "chocolate"), survivalpoints = c(10, 15, 10, 30, 30, 20, 2), weight = c(1, 10, 5, 7, 1, 5, 1))

limit <- 20

solution <- c(1, 0, 0, 1, 1, 0, 0)

data[solution==1, ]
#           item survivalpoints weight
# 1         cake             10      1
# 4 strawberries             30      7
# 5        grape             30      1

cat(solution %*% data$survivalpoints)
# 70

# Fitness function calculation.
fitness <- function(x) {
	points <- x %*% data$survivalpoints

	weight <- x %*% data$weight

	if (weight > limit) {
		return( 0 )
	} else {
		return( -points )
	}
}

iterations <- 75

model <- rbga.bin(size=7, popSize=37, iters=iterations, mutationChance=0.01, elitism=TRUE, evalFunc=fitness)

cat( summary(model) )
# GA Settings
#   Type                  = binary chromosome
#   Population size       = 37
#   Number of Generations = 1000
#   Elitism               = TRUE
#   Mutation Chance       = 0.01
# 
# Search Domain
#   Var 1 = [,]
#   Var 0 = [,]
# 
# GA Results
#   Best Solution : 1 0 1 1 1 1 1 

# Print the best found solution.
best = c(1, 0, 1, 1, 1, 1, 1)
data[best == 1, ]
#           item survivalpoints weight
# 1         cake             10      1
# 3 orange juice             10      5
# 4 strawberries             30      7
# 5        grape             30      1
# 6      candies             20      5
# 7    chocolate              2      1

# Calculate survival points.
cat(paste(best %*% data$survivalpoints, "/", sum(data$survivalpoints)))
# 102 / 117
\end{lstlisting}

\begin{lstlisting}[caption=Анимирана визуализация на процеса по търсене на оптимално решение, label=listing0177]
library(ggplot2)
library(animation)

setwd("~/Desktop")

animate <- function(x) {
	for (i in seq(1, iterations)) {
		current <- data.frame(Generation = c(seq(1, i), seq(1, i)), Variable = c(rep("mean", i), rep("best", i)), Survivalpoints = c(-model$mean[1:i], -model$best[1:i]))

		graphics <- ggplot(current, aes(x = Generation, y = Survivalpoints, group = Variable, colour = Variable)) + geom_line() + scale_x_continuous(limits = c(0,  iterations)) + scale_y_continuous(limits = c(0, 110)) + geom_hline(yintercept = 0, y = max(current$Survivalpoints), lty = 2) + annotate("text", x = 1, y = max(current$Survivalpoints) + 2, hjust = 0, size = 3, color = "black", label = paste("Best Found Solution:", max(current$Survivalpoints))) + scale_colour_brewer(palette = "Set1") + labs(title = "Evolution Knapsack Optimization Model")

		print( graphics )
    }
}

saveGIF(animate(), interval=0.1, outdir=getwd())
\end{lstlisting}

