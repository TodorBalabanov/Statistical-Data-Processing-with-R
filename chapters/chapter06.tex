\newpage
\chapter{Групиране на данни}
\label{chapter06}

Практиката показва, че около 80\% от статистическия анализ е манипулация на данните. Това често налага повтарящи се операции върху различни участъци от данните. Данните се разделят на отделни фрагменти, след това върху определени фрагменти се прилагат определени операции и накрая фрагментите се обединяват в едно цяло. 

\section{Фамилия функции apply}

Фамилията функции apply служи за групово манипулиране на данни. Тъй като има различни входно-изходни комбинации на данните, то в R е представена цяла фамилия функции, а не една единствена.

\subsection{apply}

Функцията apply е първата, която потребителите научават и тя идва с най-много ограничения. Функцията се прилага върху матрици, което означава че всичките елементи в матрицата трябва да са от един и същи тип. Ако функцията бъде приложена върху друг тип обект, то първо данните ще бъдат преобразувани до матрица. Първият аргумент при извикването е обектът който ще бъде обработван. Вторият аргумент определя дали да се работи по редове (стойност 1) или по колони (стойност 2). Третият аргумент е функцията, която трябва да се приложи. Аргументите след третия могат да са променлив брой и се предават на функцията, която е посочена в третия аргумент. 

\begin{lstlisting}[caption=Сума по редове и колони, label=listing0093]
m1 <- matrix(11:19, nrow=3)
m1
     [,1] [,2] [,3]
[1,]   11   14   17
[2,]   12   15   18
[3,]   13   16   19
 
apply(m1, 1, sum)
[1] 42 45 48
 
apply(m1, 2, sum)
[1] 36 45 54

m1[2,2] <- NA
m1
     [,1] [,2] [,3]
[1,]   11   14   17
[2,]   12   NA   18
[3,]   13   16   19

apply(m1, 1, sum)
[1] 42 NA 48

apply(m1, 2, sum)
[1] 36 NA 54

apply(m1, 1, sum, na.rm=TRUE)
[1] 42 30 48

apply(m1, 2, sum, na.rm=TRUE)
[1] 36 30 54
\end{lstlisting}

Едно от най-лесните пресмятания, за илюстрация на функцията apply, е сумата на елементите по редове и по колони в една матрица (Листинг \ref{listing0093}). Когато в матрицата има неопределени стойност (NA), подадената функция изчислява стойността до NA. Това поведение може да бъде променено, чрез игнориране на липсващите стойности, с подаване на параметъра na.rm=TRUE.

\subsection{lapply и sapply}

Функцията lapply получава като аргумент списък и връща като резултат списък (Листинг \ref{listing0094}). 

\begin{lstlisting}[caption=Сума на обекти в списък, label=listing0094]
l1 <- list(m2=matrix(1:9,3), l2=1:5, m3=matrix(1:4,2), n1=2)
l1
$m2
     [,1] [,2] [,3]
[1,]    1    4    7
[2,]    2    5    8
[3,]    3    6    9

$l2
[1] 1 2 3 4 5

$m3
     [,1] [,2]
[1,]    1    3
[2,]    2    4

$n1
[1] 2

lapply(l1, sum)
$m2
[1] 45

$l2
[1] 15

$m3
[1] 10

$n1
[1] 2

sapply(l1, sum)
m2 l2 m3 n1 
45 15 10  2
\end{lstlisting}

Ако върнатата стойност трябва да бъде вектор, то вместо lapply се използва sapply, която във всяко друго отношение работи като lappy. 

\subsection{mapply}

Функцията mapply се ползва за прилагане на функция върху всеки елемент на от множество списъци (Листинг \ref{listing0095}). 
\begin{lstlisting}[caption=Проверка за идентичност на елементите, label=listing0095]
l3 <- list(m4=matrix(1:25,5), m5=matrix(1:16,2), l4=1:5)
l5 <- list(m6=matrix(1:25,5), m7=matrix(1:16,8), l6=15:1)

mapply(identical, l3, l5)
   m4    m5    l4 
 TRUE FALSE FALSE

mapply(f1<-function(x,y){NROW(x)+NROW(y)}, l3, l5)
m4 m5 l4 
10 10 20 
\end{lstlisting}

Също така, mapply позволява и потребителски дефинирани функции.

\section{Агрегация}

При употребата на SQL е много популярно данните да се групират по признак/признаци и върху тях да бъдат изпълнявани агрегатни функции. Един от начините да се постигне агрегация в R е, чрез функцията aggregate и синтаксиса за запис на формула. Формулите се записват с лява част и дясна част, отделени със символа тилда (\textasciitilde). От лявата страна стои променливата по която ще се извършва пресмятането, а от дясната страна стои променлива (или група променливи) по която ще се извършва групирането. 

\begin{lstlisting}[caption=Групиране на данни, label=listing0096]
data(diamonds, package="ggplot2")
head(diamonds, n=3)
  carat     cut color clarity depth table price    x    y    z
1  0.23   Ideal     E     SI2  61.5    55   326 3.95 3.98 2.43
2  0.21 Premium     E     SI1  59.8    61   326 3.89 3.84 2.31
3  0.23    Good     E     VS1  56.9    65   327 4.05 4.07 2.31

aggregate(price~cut, diamonds, mean)
        cut    price
1      Fair 4358.758
2      Good 3928.864
3 Very Good 3981.760
4   Premium 4584.258
5     Ideal 3457.542
\end{lstlisting}

Като пример за групиране и използване на агрегатна функция може да се изпълни пресмятането на средна цена за диамант организирано в групи според вида на среза (Листинг \ref{listing0096}). Първият аргумент на функцията е формулата за групиране, вторият аргумент е обектът с данните, а третия аргумент е функцията, която да се приложи върху отделните групи. Тъй като вторият аргумент показва кое множество данни се използва, то във формулата не е нужно да се оказва множеството, а може да се използват директно имената на колоните. След третия аргумент могат да се добавят и други аргументи, като примерно na.rm=TRUE. 

\begin{lstlisting}[caption=Групиране по повече от една колона, label=listing0097]
aggregate(price~cut+color, diamonds, mean)
         cut color    price
1       Fair     D 4291.061
2       Good     D 3405.382
3  Very Good     D 3470.467
4    Premium     D 3631.293
5      Ideal     D 2629.095
6       Fair     E 3682.312
7       Good     E 3423.644
8  Very Good     E 3214.652
9    Premium     E 3538.914
10     Ideal     E 2597.550
...
\end{lstlisting}

Както в SQL, така и при групирането в R е възможно групирането да се извърши по повече от една колона (Листинг \ref{listing0097}).

\begin{lstlisting}[caption=Прилагане на агрегатна функция върху повече колони в едни и същи групи, label=listing0098]
aggregate(cbind(price,carat)~cut, diamonds, mean)
        cut    price     carat
1      Fair 4358.758 1.0461366
2      Good 3928.864 0.8491847
3 Very Good 3981.760 0.8063814
4   Premium 4584.258 0.8919549
5     Ideal 3457.542 0.7028370
\end{lstlisting}

Възможно е агрегатната функция да бъде приложена върху повече от една колона, като това се постига с функцията cbind (Листинг \ref{listing0098}). Особеността при това извикване е, че само една агрегатна функция може да се приложи и всички избрани колони ще бъдат пресметнати спрямо нея (в случая се изчислява средна стойност).

\begin{lstlisting}[caption=Използване на повече колони от двете страни на формулата, label=listing0099]
aggregate(cbind(price,carat)~cut+color, diamonds, mean)
         cut color    price     carat
1       Fair     D 4291.061 0.9201227
2       Good     D 3405.382 0.7445166
3  Very Good     D 3470.467 0.6964243
4    Premium     D 3631.293 0.7215471
5      Ideal     D 2629.095 0.5657657
6       Fair     E 3682.312 0.8566071
7       Good     E 3423.644 0.7451340
8  Very Good     E 3214.652 0.6763167
9    Premium     E 3538.914 0.7177450
10     Ideal     E 2597.550 0.5784012
...
\end{lstlisting}

Изпълнението на агрегатни функции позволява да има повече от една колона и от двете страни на формулата (Листинг \ref{listing0099}). При използването на функцията за агрегация трябва да се има предвид, че тя може да бъде много бавна по отношение на изпълнението, особено при данни с голям обем. 

\section{Пакетът plyr}

Пакетът plyr дава допълнителни възможности по схемата за обработка на данни разделяне-манипулиране-обединение. Ядрото на пакета се състои от функциите ddply, llply и ldply. При тези функции е използвана конвенция, която подсказва какъв е типът на входните данни и типът на изходните данни (в по-широката й употреба това е унгарската нотация \cite{hnot}). Първата буква определя входния тип данни, а втората буква определя изходния тип данни. Буквата d се използва за data.frame, буквата l за списък, буквата a за масив и символът за подчертаване (\_) при липса на върната стойност. 

\subsection{ddply}

За илюстрация на функцията ddply е удачно да се използват данните за бейзболни резултати от пакета plyr (Листинг \ref{listing0100}).

\begin{lstlisting}[caption=Бейзболна статистика, label=listing0100]
library( plyr )

head(baseball,n=3)
          id year stint team lg  g  ab  r  h X2b X3b hr rbi sb cs bb so ibb
4  ansonca01 1871     1  RC1    25 120 29 39  11   3  0  16  6  2  2  1  NA
44 forceda01 1871     1  WS3    32 162 45 45   9   4  0  29  8  0  4  0  NA
68 mathebo01 1871     1  FW1    19  89 15 24   3   1  0  10  2  1  2  0  NA
   hbp sh sf gidp
4   NA NA NA   NA
44  NA NA NA   NA
68  NA NA NA   NA
\end{lstlisting}

В това множество данни са отчетени 21699 записа в бейзболната статистика за 1228 играча, в диапазона от годините 1871 до 2007. Включени са само играчи с 15 или повече сезона игра. В множеството се отчитат 22 признака (колони), със следното значение:

\begin{table}[h!]
\centering
\begin{tabular}{|l|r|} 
  \rowcolor{lightgray}
  \hline
  Характеристика & Значение \\ [0.1ex] 
  \hline\hline
  id & Идентификатор на играча (символен низ) \\
  \hline
  year & Година на събраните данни (цяло число) \\
  \hline
  stint & Ограничения (цяло число) \\
  \hline
  team & Отбор в който играе (символен низ) \\
  \hline
  lg & Лига в която играе (символен низ) \\
  \hline
  g & Брой игри (цяло число) \\
  \hline
  ab & Брой батирания (цяло число) \\
  \hline
  r & Брой пробягвания (цяло число) \\
  \hline
  h & Брой реализирани удари (цяло число) \\
  \hline
  X2b & Брой успешни достигания до втора база (цяло число) \\
  \hline
  X3b & Брой успешни достигания до трета база (цяло число) \\
  \hline
  hr & Брой успешни хум ръна (цяло число) \\
  \hline
  rbi & Брой тичания в които е удрял (цяло число) \\
  \hline
  sb & Брой откраднати бази (цяло число) \\
  \hline
  cs & Брой хванати отнемания (цяло число) \\
  \hline
  bb & Брой пробягвания (цяло число) \\
  \hline
  so & Брой изхвърлени изстрели (цяло число) \\
  \hline
  ibb & Брой международни пробягвания (цяло число) \\
  \hline
  hbp & Брой попадения от питчъра (цяло число) \\
  \hline
  sh & Брой пожертвани удари (цяло число) \\
  \hline
  sf & Брой пожертвани изстрела (цяло число) \\
  \hline
  gidp & Брой приземявания при двойна игра (цяло число) \\
  \hline
\end{tabular}
\caption{Характеристики на бейзболните играчи}
\label{table0003}
\end{table}

Основна статистика в бейзбола е OBP (On Base Percentage), която се изчислява по формула \ref{equation0001}.

\begin{equation}
OBP = \frac{H + BB + HBP}{AB + BB + HBP + SF}
\label{equation0001}
\end{equation}
\listofequations{On Base Percentage (OBP) статистика}

Където:
H – брой удари,
BB – пробягвания,
HBP – брой попадения от питчъра,
AB – удари на батата,
SF – пропуснати изстрели.

Преди 1954 година, за SF стойностите са 0, поради различния начин за отчитане на статистиката. В данните има множество NA стойности за HBP. Липсващите стойности трябва да се заменят с 0. От множеството данни се изключват и всички редове за които AB е по-малко от 50 (Листинг \ref{listing0101}).

\begin{lstlisting}[caption=Корекция на данните, label=listing0101]
any( is.na(baseball$sf) )
[1] TRUE

baseball$sf[baseball$year < 1954] <- 0

any( is.na(baseball$sf) )
[1] FALSE

any( is.na(baseball$hbp) )
[1] TRUE
 
baseball$hbp[ is.na(baseball$hbp) ] <- 0
 
any( is.na(baseball$hbp) )
[1] FALSE

baseball <- baseball[baseball$ab>=50,]
\end{lstlisting}

Пресмятането на OBP коефициентът за всеки играч, за конкретна година е изключително лесно поради възможността да се изпълни векторно пресмятане (Листинг \ref{listing0102}).

\begin{lstlisting}[caption=Пресмятане на OBP, label=listing0102]
baseball$OBP <- with(baseball, (h+bb+hbp)/(ab+bb+hbp+sf))

head(cbind(baseball$id,baseball$OBP), n=3)
     [,1]        [,2]               
[1,] "ansonca01" "0.336065573770492"
[2,] "forceda01" "0.295180722891566"
[3,] "mathebo01" "0.285714285714286"
\end{lstlisting}

Функцията with позволява да се упомене обекта с данните само един път, а в следващите аргументи да се използват само имената на колоните, без да се уточнява на кое множество данни принадлежат. 

\section*{Заключение}
