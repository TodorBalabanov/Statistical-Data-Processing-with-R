\newpage
\chapter{Групиране и обхождане на данни}
\label{chapter06}

Практиката показва, че около 80\% от статистическия анализ е манипулация на данните. Това често налага повтарящи се операции върху различни участъци от данните. Данните се разделят на отделни фрагменти, след това върху определени фрагменти се прилагат определени операции и накрая фрагментите се обединяват в едно цяло. 

\section{Фамилията функции apply}

Фамилията функции apply служи за групово манипулиране на данни. Тъй като има различни входно-изходни комбинации на данните, то в R е представена цяла фамилия функции, а не една единствена.

\subsection{apply}

Функцията apply е първата, която потребителите научават и тя идва с най-много ограничения. Функцията се прилага върху матрици, което означава че всичките елементи в матрицата трябва да са от един и същи тип. Ако функцията бъде приложена върху друг тип обект, то първо данните ще бъдат преобразувани до матрица. Първият аргумент при извикването е обектът който ще бъде обработван. Вторият аргумент определя дали да се работи по редове (стойност 1) или по колони (стойност 2). Третият аргумент е функцията, която трябва да се приложи. Аргументите след третия могат да са променлив брой и се предават на функцията, която е посочена в третия аргумент. 

\begin{lstlisting}[caption=Сума по редове и колони, label=listing0093]
m1 <- matrix(11:19, nrow=3)
m1
     [,1] [,2] [,3]
[1,]   11   14   17
[2,]   12   15   18
[3,]   13   16   19
 
apply(m1, 1, sum)
[1] 42 45 48
 
apply(m1, 2, sum)
[1] 36 45 54

m1[2,2] <- NA
m1
     [,1] [,2] [,3]
[1,]   11   14   17
[2,]   12   NA   18
[3,]   13   16   19

apply(m1, 1, sum)
[1] 42 NA 48

apply(m1, 2, sum)
[1] 36 NA 54

apply(m1, 1, sum, na.rm=TRUE)
[1] 42 30 48

apply(m1, 2, sum, na.rm=TRUE)
[1] 36 30 54
\end{lstlisting}

Едно от най-лесните пресмятания, за илюстрация на функцията apply, е сумата на елементите по редове и по колони в една матрица (Листинг \ref{listing0093}). Когато в матрицата има неопределени стойност (NA), подадената функция изчислява стойността до NA. Това поведение може да бъде променено, чрез игнориране на липсващите стойности, с подаване на параметъра na.rm=TRUE.

\subsection{lapply и sapply}

Функцията lapply получава като аргумент списък и връща като резултат списък (Листинг \ref{listing0094}). 

\begin{lstlisting}[caption=Сума на обекти в списък, label=listing0094]
l1 <- list(m2=matrix(1:9,3), l2=1:5, m3=matrix(1:4,2), n1=2)
l1
$m2
     [,1] [,2] [,3]
[1,]    1    4    7
[2,]    2    5    8
[3,]    3    6    9

$l2
[1] 1 2 3 4 5

$m3
     [,1] [,2]
[1,]    1    3
[2,]    2    4

$n1
[1] 2

lapply(l1, sum)
$m2
[1] 45

$l2
[1] 15

$m3
[1] 10

$n1
[1] 2

sapply(l1, sum)
m2 l2 m3 n1 
45 15 10  2
\end{lstlisting}

Ако върнатата стойност трябва да бъде вектор, то вместо lapply се използва sapply, която във всяко друго отношение работи като lappy. 

\subsection{mapply}

Функцията mapply се ползва за прилагане на функция върху всеки елемент на от множество списъци (Листинг \ref{listing0095}). 
\begin{lstlisting}[caption=Проверка за идентичност на елементите, label=listing0095]
l3 <- list(m4=matrix(1:25,5), m5=matrix(1:16,2), l4=1:5)
l5 <- list(m6=matrix(1:25,5), m7=matrix(1:16,8), l6=15:1)

mapply(identical, l3, l5)
   m4    m5    l4 
 TRUE FALSE FALSE

mapply(f1<-function(x,y){NROW(x)+NROW(y)}, l3, l5)
m4 m5 l4 
10 10 20 
\end{lstlisting}

Също така, mapply позволява и потребителски дефинирани функции.

\subsection{Агрегация}

При употребата на SQL е много популярно данните да се групират по признак/признаци и върху тях да бъдат изпълнявани агрегатни функции. Един от начините да се постигне агрегация в R е, чрез функцията aggregate и синтаксиса за запис на формула. Формулите се записват с лява част и дясна част, отделени със символа тилда (\textasciitilde). От лявата страна стои променливата по която ще се извършва пресмятането, а от дясната страна стои променлива (или група променливи) по която ще се извършва групирането. 

\begin{lstlisting}[caption=Групиране на данни, label=listing0096]
data(diamonds, package="ggplot2")
head(diamonds, n=3)
  carat     cut color clarity depth table price    x    y    z
1  0.23   Ideal     E     SI2  61.5    55   326 3.95 3.98 2.43
2  0.21 Premium     E     SI1  59.8    61   326 3.89 3.84 2.31
3  0.23    Good     E     VS1  56.9    65   327 4.05 4.07 2.31

aggregate(price~cut, diamonds, mean)
        cut    price
1      Fair 4358.758
2      Good 3928.864
3 Very Good 3981.760
4   Premium 4584.258
5     Ideal 3457.542
\end{lstlisting}

Като пример за групиране и използване на агрегатна функция може да се изпълни пресмятането на средна цена за диамант организирано в групи според вида на среза (Листинг \ref{listing0096}). Първият аргумент на функцията е формулата за групиране, вторият аргумент е обектът с данните, а третия аргумент е функцията, която да се приложи върху отделните групи. Тъй като вторият аргумент показва кое множество данни се използва, то във формулата не е нужно да се оказва множеството, а може да се използват директно имената на колоните. След третия аргумент могат да се добавят и други аргументи, като примерно na.rm=TRUE. 

\begin{lstlisting}[caption=Групиране по повече от една колона, label=listing0097]
aggregate(price~cut+color, diamonds, mean)
         cut color    price
1       Fair     D 4291.061
2       Good     D 3405.382
3  Very Good     D 3470.467
4    Premium     D 3631.293
5      Ideal     D 2629.095
6       Fair     E 3682.312
7       Good     E 3423.644
8  Very Good     E 3214.652
9    Premium     E 3538.914
10     Ideal     E 2597.550
...
\end{lstlisting}

Както в SQL, така и при групирането в R е възможно групирането да се извърши по повече от една колона (Листинг \ref{listing0097}).

\begin{lstlisting}[caption=Прилагане на агрегатна функция върху повече колони в едни и същи групи, label=listing0098]
aggregate(cbind(price,carat)~cut, diamonds, mean)
        cut    price     carat
1      Fair 4358.758 1.0461366
2      Good 3928.864 0.8491847
3 Very Good 3981.760 0.8063814
4   Premium 4584.258 0.8919549
5     Ideal 3457.542 0.7028370
\end{lstlisting}

Възможно е агрегатната функция да бъде приложена върху повече от една колона, като това се постига с функцията cbind (Листинг \ref{listing0098}). Особеността при това извикване е, че само една агрегатна функция може да се приложи и всички избрани колони ще бъдат пресметнати спрямо нея (в случая се изчислява средна стойност).

\begin{lstlisting}[caption=Използване на повече колони от двете страни на формулата, label=listing0099]
aggregate(cbind(price,carat)~cut+color, diamonds, mean)
         cut color    price     carat
1       Fair     D 4291.061 0.9201227
2       Good     D 3405.382 0.7445166
3  Very Good     D 3470.467 0.6964243
4    Premium     D 3631.293 0.7215471
5      Ideal     D 2629.095 0.5657657
6       Fair     E 3682.312 0.8566071
7       Good     E 3423.644 0.7451340
8  Very Good     E 3214.652 0.6763167
9    Premium     E 3538.914 0.7177450
10     Ideal     E 2597.550 0.5784012
...
\end{lstlisting}

Изпълнението на агрегатни функции позволява да има повече от една колона и от двете страни на формулата (Листинг \ref{listing0099}). При използването на функцията за агрегация трябва да се има предвид, че тя може да бъде много бавна по отношение на изпълнението, особено при данни с голям обем. 

\section{Пакетът plyr}

Пакетът plyr дава допълнителни възможности по схемата за обработка на данни разделяне-манипулиране-обединение. Ядрото на пакета се състои от функциите ddply, llply и ldply. При тези функции е използвана конвенция, която подсказва какъв е типът на входните данни и типът на изходните данни (в по-широката й употреба това е унгарската нотация \cite{hnot}). Първата буква определя входния тип данни, а втората буква определя изходния тип данни. Буквата d се използва за data.frame, буквата l за списък, буквата a за масив и символът за подчертаване (\_) при липса на върната стойност. 

\subsection{ddply}

За илюстрация на функцията ddply е удачно да се използват данните за бейзболни резултати от пакета plyr (Листинг \ref{listing0100}).

\begin{lstlisting}[caption=Бейзболна статистика, label=listing0100]
library( plyr )

head(baseball,n=3)
          id year stint team lg  g  ab  r  h X2b X3b hr rbi sb cs bb so ibb
4  ansonca01 1871     1  RC1    25 120 29 39  11   3  0  16  6  2  2  1  NA
44 forceda01 1871     1  WS3    32 162 45 45   9   4  0  29  8  0  4  0  NA
68 mathebo01 1871     1  FW1    19  89 15 24   3   1  0  10  2  1  2  0  NA
   hbp sh sf gidp
4   NA NA NA   NA
44  NA NA NA   NA
68  NA NA NA   NA
\end{lstlisting}

В това множество данни са отчетени 21699 записа в бейзболната статистика за 1228 играча, в диапазона от годините 1871 до 2007. Включени са само играчи с 15 или повече сезона игра. В множеството се отчитат 22 признака (колони), със следното значение:

\begin{table}[h!]
\centering
\begin{tabular}{|l|r|} 
  \rowcolor{lightgray}
  \hline
  Характеристика & Значение \\ [0.1ex] 
  \hline\hline
  id & Идентификатор на играча (символен низ) \\
  \hline
  year & Година на събраните данни (цяло число) \\
  \hline
  stint & Ограничения (цяло число) \\
  \hline
  team & Отбор в който играе (символен низ) \\
  \hline
  lg & Лига в която играе (символен низ) \\
  \hline
  g & Брой игри (цяло число) \\
  \hline
  ab & Брой батирания (цяло число) \\
  \hline
  r & Брой пробягвания (цяло число) \\
  \hline
  h & Брой реализирани удари (цяло число) \\
  \hline
  X2b & Брой успешни достигания до втора база (цяло число) \\
  \hline
  X3b & Брой успешни достигания до трета база (цяло число) \\
  \hline
  hr & Брой успешни хум ръна (цяло число) \\
  \hline
  rbi & Брой тичания в които е удрял (цяло число) \\
  \hline
  sb & Брой откраднати бази (цяло число) \\
  \hline
  cs & Брой хванати отнемания (цяло число) \\
  \hline
  bb & Брой пробягвания (цяло число) \\
  \hline
  so & Брой изхвърлени изстрели (цяло число) \\
  \hline
  ibb & Брой международни пробягвания (цяло число) \\
  \hline
  hbp & Брой попадения от питчъра (цяло число) \\
  \hline
  sh & Брой пожертвани удари (цяло число) \\
  \hline
  sf & Брой пожертвани изстрела (цяло число) \\
  \hline
  gidp & Брой приземявания при двойна игра (цяло число) \\
  \hline
\end{tabular}
\caption{Характеристики на бейзболните играчи}
\label{table0003}
\end{table}

Основна статистика в бейзбола е OBP (On Base Percentage), която се изчислява по формула \ref{equation0001}.

\begin{equation}
OBP = \frac{H + BB + HBP}{AB + BB + HBP + SF}
\label{equation0001}
\end{equation}
\listofequations{On Base Percentage (OBP) статистика}

Където:
H – брой удари,
BB – пробягвания,
HBP – брой попадения от питчъра,
AB – удари на батата,
SF – пропуснати изстрели.

Преди 1954 година, за SF стойностите са 0, поради различния начин за отчитане на статистиката. В данните има множество NA стойности за HBP. Липсващите стойности трябва да се заменят с 0. От множеството данни се изключват и всички редове за които AB е по-малко от 50 (Листинг \ref{listing0101}).

\begin{lstlisting}[caption=Корекция на данните, label=listing0101]
any( is.na(baseball$sf) )
[1] TRUE

baseball$sf[baseball$year < 1954] <- 0

any( is.na(baseball$sf) )
[1] FALSE

any( is.na(baseball$hbp) )
[1] TRUE
 
baseball$hbp[ is.na(baseball$hbp) ] <- 0
 
any( is.na(baseball$hbp) )
[1] FALSE

baseball <- baseball[baseball$ab>=50,]
\end{lstlisting}

Пресмятането на OBP коефициентът за всеки играч, за конкретна година е изключително лесно поради възможността да се изпълни векторно пресмятане (Листинг \ref{listing0102}).

\begin{lstlisting}[caption=Пресмятане на OBP, label=listing0102]
baseball$OBP <- with(baseball, (h+bb+hbp)/(ab+bb+hbp+sf))

head(cbind(baseball$id,baseball$OBP), n=3)
     [,1]        [,2]               
[1,] "ansonca01" "0.336065573770492"
[2,] "forceda01" "0.295180722891566"
[3,] "mathebo01" "0.285714285714286"
\end{lstlisting}


Функцията with позволява да се упомене обекта с данните само един път, а в следващите аргументи да се използват само имената на колоните, без да се уточнява на кое множество данни принадлежат. 

OBP коефициента за цялата кариера на играча не може да се пресметне чрез просто усредняване на сезонния OBP коефициент. Трябва да се пресметне и сумира числителят и след това да се раздели на сумата в делителя. Това може да се постигне с функцията ddply (Листинг \ref{listing0103}).

\begin{lstlisting}[caption=Пресмятане на OBP за цялата кариера на играча, label=listing0103]
career <- ddply(baseball, .variables="id", .fun=function(data){c(OBP=with(data,sum(h+bb+hbp)/sum(ab+bb+hbp+sf)))})

career <- career[order(career$OBP,decreasing=TRUE), ]

head(career, n=3)
            id       OBP
1089 willite01 0.4816861
875   ruthba01 0.4742209
658  mcgrajo01 0.4657478
\end{lstlisting}

Вградената потребителска функция извършва пресмятането, а след това ddply изпълнява пресмятането върху всеки играч. Полученият резултат е сортиран в нисходящ ред, според кариерния OBP коефициент.

\subsection{llply}

Функцията llply може да бъде използвана по аналогичен начин както се използва функцията lapply (Листинг \ref{listing0104}).

\begin{lstlisting}[caption=Сума на всеки елемент в списък, label=listing0104]
l1 <- list(m2=matrix(1:9,3), l2=1:5, m3=matrix(1:4,2), n1=2)

llply(l1, sum)
$m2
[1] 45

$l2
[1] 15

$m3
[1] 10

$n1
[1] 2

identical(lapply(l1,sum), llply(l1,sum))
[1] TRUE

laply(l1, sum)
[1] 45 15 10  2
\end{lstlisting}

Функцията laply извършва същото пресмятане, но връща резултата под формата на вектор. 

\subsection{Помощни функции и бързодействие}

В пакета plyr са добавени група помощни функции, като функцията each, която позволява да се изпращат повече от една агрегатна функция на функцията aggregate (Листинг \ref{listing0105}). Недостатък на each е, че тя отнема възможността за изпращане на допълнителни параметри. 

\begin{lstlisting}[caption=Повече от една агрегатни функции, label=listing0105]
library(ggplot2)

aggregate(price~cut, diamonds, each(mean, median))
        cut price.mean price.median
1      Fair   4358.758     3282.000
2      Good   3928.864     3050.500
3 Very Good   3981.760     2648.000
4   Premium   4584.258     3185.000
5     Ideal   3457.542     1810.000
\end{lstlisting}

Друга полезна функция е idata.frame, която позволява създаването на референция към data.frame, така че формирането на подмножества да става по-бързо и при значително по-ниска консумация на оперативна памет (Листинг \ref{listing0106}). 

\begin{lstlisting}[caption=Бързодействие при използване на референции, label=listing0106]
system.time(dlply(baseball, "id", nrow))
   user  system elapsed 
  0.159   0.009   0.169 

reference <- idata.frame( baseball )

system.time(dlply(reference, "id", nrow))
   user  system elapsed 
  0.178   0.005   0.183
\end{lstlisting}

Ускорението което ще се постигне много зависи от размера на данните и от вида на пресмятането, което се извършва над тях. Пакетът plyr често води до компромис с бързодействието в замяна на по-голямо удобство при пресмятането. Повечето функции в пакета може да се изпълнят и с функции от базовата инсталация, plyr просто дава по-удобен начин за пресмятане. 

\section{Пакетът data.table}

Този пакет е създаден с идеята да увеличи възможностите за използване на data.frame структурата от данни. Пакетът изисква малко по-различен синтаксис за работа, спрямо този който вече е наложен при използването на data.frame. Бързодействието при data.table основно се дължи на това, че вътрешната реализация е аналогична на индексите при базите данни. Това позволява по-бърз достъп до данните, по-бързи операции за групиране и по-бързи операции за сливане (join). 

\begin{lstlisting}[caption=Създаване на data.table, label=listing0107]
library(data.table)

df <- data.frame(x1=10:1, x2=letters[11:20], x3=LETTERS[1:10], x4=rep(c("One", "Two", "Three"), length.out=10))
 
df
   x1 x2 x3    x4
1  10  k  A   One
2   9  l  B   Two
3   8  m  C Three
4   7  n  D   One
5   6  o  E   Two
6   5  p  F Three
7   4  q  G   One
8   3  r  H   Two
9   2  s  I Three
10  1  t  J   One

class( df$x2 )
[1] "factor"

dt <- data.table(x1=10:1, x2=letters[11:20], x3=LETTERS[1:10], x4=rep(c("One", "Two", "Three"), length.out=10))
 
dt
    x1 x2 x3    x4
 1: 10  k  A   One
 2:  9  l  B   Two
 3:  8  m  C Three
 4:  7  n  D   One
 5:  6  o  E   Two
 6:  5  p  F Three
 7:  4  q  G   One
 8:  3  r  H   Two
 9:  2  s  I Three
10:  1  t  J   One

class( dt$x2 )
[1] "character"
\end{lstlisting}

Създаването на data.table не се различава особено от създаването на data.frame (Листинг \ref{listing0107}). Зареждането на данни е идентично с разликата, че data.frame преобразува символните низове до фактори, докато data.table ги запазва, като символни низове. 

\begin{lstlisting}[caption=Зареждане на data.table от data.frame, label=listing0108]
diamonds <- data.table(diamonds)

diamonds
       carat       cut color clarity depth table price    x    y    z
    1:  0.23     Ideal     E     SI2  61.5    55   326 3.95 3.98 2.43
    2:  0.21   Premium     E     SI1  59.8    61   326 3.89 3.84 2.31
    3:  0.23      Good     E     VS1  56.9    65   327 4.05 4.07 2.31
    4:  0.29   Premium     I     VS2  62.4    58   334 4.20 4.23 2.63
    5:  0.31      Good     J     SI2  63.3    58   335 4.34 4.35 2.75
   ---                                                               
53936:  0.72     Ideal     D     SI1  60.8    57  2757 5.75 5.76 3.50
53937:  0.72      Good     D     SI1  63.1    55  2757 5.69 5.75 3.61
53938:  0.70 Very Good     D     SI1  62.8    60  2757 5.66 5.68 3.56
53939:  0.86   Premium     H     SI2  61.0    58  2757 6.15 6.12 3.74
53940:  0.75     Ideal     D     SI2  62.2    55  2757 5.83 5.87 3.64
\end{lstlisting}

Създаването на data.table от data.frame става, чрез просто извикване на функцията (Листинг \ref{listing0108}). При разпечатването на резултата има разлика в това, че се показват първите пет и последните пет реда от данните. 

\begin{lstlisting}[caption=Достъп до редовете, label=listing0109]
dt[1:2, ]
   x1 x2 x3  x4
1: 10  k  A One
2:  9  l  B Two

dt[dt$x1>=7, ]
   x1 x2 x3    x4
1: 10  k  A   One
2:  9  l  B   Two
3:  8  m  C Three
4:  7  n  D   One

dt[x1>=7, ]
   x1 x2 x3    x4
1: 10  k  A   One
2:  9  l  B   Two
3:  8  m  C Three
4:  7  n  D   One
\end{lstlisting}

Достъпът до редовете се осъществява по аналогичен начин, както е при data.frame (Листинг \ref{listing0109}). Третото позоваване е възможно, тъй като data.table знае как да открие нужната колона и без да е указана точната data.table променлива. 

\begin{lstlisting}[caption=Достъп до колоните, label=listing0110]
dt[,list(x3,x4)]
    x3    x4
 1:  A   One
 2:  B   Two
 3:  C Three
 4:  D   One
 5:  E   Two
 6:  F Three
 7:  G   One
 8:  H   Two
 9:  I Three
10:  J   One

dt[, x1]
 [1] 10  9  8  7  6  5  4  3  2  1

dt[,list(x2)]
    x2
 1:  k
 2:  l
 3:  m
 4:  n
 5:  o
 6:  p
 7:  q
 8:  r
 9:  s
10:  t

dt[, "x4", with=FALSE]
       x4
 1:   One
 2:   Two
 3: Three
 4:   One
 5:   Two
 6: Three
 7:   One
 8:   Two
 9: Three
10:   One

td[, c("x2", "x3"), with=FALSE]
    x2 x3
 1:  k  A
 2:  l  B
 3:  m  C
 4:  n  D
 5:  o  E
 6:  p  F
 7:  q  G
 8:  r  H
 9:  s  I
10:  t  J
\end{lstlisting}

Достъпът до колоните се осъществява малко по-различно спрямо data.frame (Листинг \ref{listing0110}). За да се позоват колоните като символни низове (примерно получени след някакво пресмятане) трябва да се подаде лъжа на параметъра with. 

\subsection{Ключове}

При наличие на няколко таблици в паметта, то с тях може да се изпълнят серия операции. Като начало, списък с наличните таблици може да се получи чрез функцията tables (Листинг \ref{listing0111}).

\begin{lstlisting}[caption=Операции с таблици, label=listing0111]
tables()
       NAME   NROW NCOL MB                                    COLS KEY
1: diamonds 53,940   10  3 carat,cut,color,clarity,depth,table,...    
2:       dt     10    4  0                             x1,x2,x3,x4    
Total: 3MB

setkey(dt, x4)

dt
    x1 x2 x3    x4
 1: 10  k  A   One
 2:  7  n  D   One
 3:  4  q  G   One
 4:  1  t  J   One
 5:  8  m  C Three
 6:  5  p  F Three
 7:  2  s  I Three
 8:  9  l  B   Two
 9:  6  o  E   Two
10:  3  r  H   Two

tables()
       NAME   NROW NCOL MB                                    COLS KEY
1: diamonds 53,940   10  3 carat,cut,color,clarity,depth,table,...    
2:       dt     10    4  0                             x1,x2,x3,x4  x4
Total: 3MB

key( dt )
[1] "x4"

dt["One", ]
   x1 x2 x3  x4
1: 10  k  A One
2:  7  n  D One
3:  4  q  G One
4:  1  t  J One

dt[c("One","Two"), ]
   x1 x2 x3  x4
1: 10  k  A One
2:  7  n  D One
3:  4  q  G One
4:  1  t  J One
5:  9  l  B Two
6:  6  o  E Two
7:  3  r  H Two

setkey(diamonds, cut, color)

diamonds
       carat   cut color clarity depth table price    x    y    z
    1:  0.75  Fair     D     SI2  64.6    57  2848 5.74 5.72 3.70
    2:  0.71  Fair     D     VS2  56.9    65  2858 5.89 5.84 3.34
    3:  0.90  Fair     D     SI2  66.9    57  2885 6.02 5.90 3.99
    4:  1.00  Fair     D     SI2  69.3    58  2974 5.96 5.87 4.10
    5:  1.01  Fair     D     SI2  64.6    56  3003 6.31 6.24 4.05
   ---                                                           
53936:  0.71 Ideal     J     SI1  60.6    57  2700 5.78 5.83 3.52
53937:  0.81 Ideal     J     VS2  62.1    56  2708 5.92 5.97 3.69
53938:  0.84 Ideal     J     VS2  61.1    57  2709 6.09 6.12 3.73
53939:  0.82 Ideal     J     VS2  61.6    56  2741 6.00 6.04 3.71
53940:  0.83 Ideal     J     VS2  62.3    55  2742 6.01 6.03 3.75

diamonds[J("Fair", "J"), ]
     carat  cut color clarity depth table price    x    y    z
  1:  1.05 Fair     J     SI2  65.8    59  2789 6.41 6.27 4.18
  2:  1.00 Fair     J     VS2  65.7    59  2811 6.14 6.07 4.01
  3:  0.99 Fair     J     SI1  55.0    61  2812 6.72 6.67 3.68
  4:  0.90 Fair     J     VS2  65.0    56  2815 6.08 6.04 3.94
  5:  0.91 Fair     J     VS2  64.4    62  2854 6.06 6.03 3.89
 ---                                                          
115:  0.90 Fair     J     SI1  64.6    61  2438 5.92 5.87 3.81
116:  0.96 Fair     J     SI1  67.3    56  2517 6.06 6.01 4.06
117:  0.90 Fair     J     SI2  66.6    54  2536 6.05 5.99 4.01
118:  0.97 Fair     J     SI2  60.8    67  2538 6.41 6.32 3.87
119:  1.01 Fair     J     SI2  66.9    58  2683 6.13 6.07 4.08
\end{lstlisting}

Както се вижда, нито една от таблиците няма присвоен ключ. Ключът е индексирана колона, която дава допълнително бързодействие при извършването на някои операции. При наличие на ключово поле е възможно изборът на редове да става и чрез подаване на стойности от ключовото поле. Ключът може да бъде и съставен, ако съдържа повече от едно поле. С функцията J служи за достъп до редовете според стойности на съставния ключ. 

\subsection{Агрегация}

Основното предимство на индексираните данни е бързодействието при изпълнението на агрегатни функции. Въпреки че aggregate и фамилията функции d*ply работят с data.table обекти (Листинг \ref{listing0112}), то използването им е свързано с бавно изпълнение. 

\begin{lstlisting}[caption=Агрегатни функции, label=listing0112]
aggregate(price~cut, diamonds, mean)
        cut    price
1      Fair 4358.758
2      Good 3928.864
3 Very Good 3981.760
4   Premium 4584.258
5     Ideal 3457.542

diamonds[, list(price=mean(price)), by=cut]
         cut    price
1:      Fair 4358.758
2:      Good 3928.864
3: Very Good 3981.760
4:   Premium 4584.258
5:     Ideal 3457.542

diamonds[, list(price=mean(price)), by=list(cut,color)]
          cut color    price
 1:      Fair     D 4291.061
 2:      Fair     E 3682.312
 3:      Fair     F 3827.003
 4:      Fair     G 4239.255
 5:      Fair     H 5135.683
 6:      Fair     I 4685.446
 7:      Fair     J 4975.655
...
29:     Ideal     D 2629.095
30:     Ideal     E 2597.550
31:     Ideal     F 3374.939
32:     Ideal     G 3720.706
33:     Ideal     H 3889.335
34:     Ideal     I 4451.970
35:     Ideal     J 4918.186
          cut color    price

diamonds[, list(price=mean(price),carat=sum(carat)), by=list(cut,color)]
          cut color    price   carat
 1:      Fair     D 4291.061  149.98
 2:      Fair     E 3682.312  191.88
 3:      Fair     F 3827.003  282.27
 4:      Fair     G 4239.255  321.48
 5:      Fair     H 5135.683  369.41
 6:      Fair     I 4685.446  209.66
 7:      Fair     J 4975.655  159.60
...
29:     Ideal     D 2629.095 1603.38
30:     Ideal     E 2597.550 2257.50
31:     Ideal     F 3374.939 2509.20
32:     Ideal     G 3720.706 3422.29
33:     Ideal     H 3889.335 2490.52
34:     Ideal     I 4451.970 1910.97
35:     Ideal     J 4918.186  952.98
          cut color    price   carat
\end{lstlisting}

По-добрият вариант е да се използват вградените в data.table агрегатни функции. За да бъде агрегацията по повече от една колона, то нужните колони се подават като списък. За разлика от предишната агрегация, тук могат да се подават различни агрегатни функции (средна и сума, в показания пример), както и да се ползват списък от колони за групиране и за агрегиране. 

\section{Бързи операции с пакета dplyr}

Пакетът dplyr е създаден основно с идеята за ускорение на изпълнението, спрямо бързодействието постигнато в пакета plyr. Пакетът dplyr основно борави с обекти от тип data.frame, а за списъци и вектори е предназначен пакетът purrr. Характерно за dplyr е, че използва названия на някои от функциите, които са добре познати в езика SQL. 

Когато се работи едновременно с пакетите plyr и dplyr е важен редът на зареждането им, тъй като последно заредения пакет в R е с приоритет, при наличие на едноименни функции. При колизия на имената конфликтът се разрешава чрез операцията за принадлежност към пакет (::), като от лявата страна е името на пакета, а от дясната страна името на функцията. Пример за такава колизия е функцията за обобщение на данните в двата пакета - plyr::summarize и dplyr::summarize.

\subsection{Потоци и таблици}

Концепцията за потоците (pipes) е развита още с първите масово използвани операционни системи, а в езика R тя е възможна благодарение на пакета magrittr. При класическата работа с функции, резултатът от извикването на първата функция се записва в междинна променлива, тази променлива се подава като аргумент на втората функция, която на свой ред записва във втора междинна променлива и този процес може да се повтаря многократно. Потоците позволяват да се избегне използването на междинни променливи, а използването на функциите да се организира като една верига от извиквания (Листинг \ref{listing0113}). Синтаксисът за поточна операция в R е два символа за процент и знакът за по-голямо между тях (\%>\%).

\begin{lstlisting}[caption=Поточни операции, label=listing0113]
library( ggplot2 )
library( magrittr )
 
dim( head(diamonds,n=4) )
[1]  4 10
 
diamonds %>% head(4) %>% dim
[1]  4 10
\end{lstlisting}

С поточната операция се подава обекта, като първи аргумент на съответната функция. Поточните операции могат да се навързват във верига и обектът в резултат от изпълнението на една функция да се предава към следваща. 

По аналогия с обектите от тип data.table, пакетът dplyr предлага разширение на data.frame под формата на tbl обекти, които се доразвиват и в пакета tibble. Съществено за tbl е, че при разпечатване се показват само подмножество на редовете, но също и подмножество на колоните, докато бъде изпълнен екрана. Третата разлика е, че под имената на колоните се визуализира информация за типът данни в колоната. При по-новите реализации на пакета ggplot2, данните за диамантите са представени и като tbl обект (Листинг \ref{listing0114}).

\begin{lstlisting}[caption=Таблични данни в dplyr, label=listing0114]
class( diamonds )
[1] "tbl_df"     "tbl"        "data.frame"

head(diamonds, n=3)
# A tibble: 3 x 10
  carat cut     color clarity depth table price     x     y     z
  <dbl> <ord>   <ord> <ord>   <dbl> <dbl> <int> <dbl> <dbl> <dbl>
1  0.23 Ideal   E     SI2      61.5    55   326  3.95  3.98  2.43
2  0.21 Premium E     SI1      59.8    61   326  3.89  3.84  2.31
3  0.23 Good    E     VS1      56.9    65   327  4.05  4.07  2.31
\end{lstlisting}

\subsection{Избор на редове}

По аналогия с SQL, функцията select извършва подбор на редове от зададено множество данни (Листинг \ref{listing0115}). Първият аргумент е data.frame (или tbl обект), а следващите аргументи изброяват желаните колони. Функцията може да се използва самостоятелно или с потоци.

\begin{lstlisting}[caption=Избор на редове, label=listing0115]
library( dplyr )

select(diamonds, carat, price)
diamonds %>% select(carat, price)
diamonds %>% select(c(carat, price))

diamonds %>% select_('carat', 'price')
names <- c('carat', 'price')
diamonds %>% select_(.dots=names)

diamonds %>% select( one_of('carat', 'price') )
names <- c('carat', 'price')
diamonds %>% select( one_of(names) )

select(diamonds, 1, 7)
diamonds %>% select(1, 7)
\end{lstlisting}

Функцията select позволява извикване по множество различни начини, които могат да доведат до един и същи начин. Като аргументи, select получава директно имената на колоните, без те да са обградени в кавички (тоест не са символни низове). Когато е нужно имената на колоните да се подават като символни низове се използва функцията select\_, която се различава в името си с една подчертавка в края. Ако имената на колоните са запазени в променлива то те се подават на .dots параметъра. От версия 0.6.0 на пакета dplyr не се препоръчва използването на функцията select\_, а заместването й с функцията select и аргумент върнат, като стойност от функцията one\_of. На функцията select освен имена на колони, може да се подават и техните индекси. 

\begin{lstlisting}[caption=Търсене по частично съвпадение, label=listing0116]
diamonds %>% select( starts_with('c') )
diamonds %>% select( ends_with('e') )
diamonds %>% select( contains('l') )

diamonds %>% select( matches('r.+t') )
\end{lstlisting}

Понякога в практиката се налага подбор на колони в множеството от данни по критерии за частично съвпадение (Листинг \ref{listing0116}). При такава ситуация за начало се ползва функцията starts\_with, за край функцията ends\_with, а за съдържание функцията contains. При частичния избор е възможно да с използват и ретуларни изрази. 

\begin{lstlisting}[caption=Изключване на колони, label=listing0117]
diamonds %>% select(-carat, -price)
diamonds %>% select( -c(carat, price) )
diamonds %>% select(-1, -7)
diamonds %>% select( -c(1,7) )
diamonds %>% select_(.dots=c('-carat', '-price'))
diamonds %>% select( -one_of('carat','price') )
\end{lstlisting}

В някои ситуации от множеството колони трябва да се изключат една част. Това се постига със записване на знак минус пред името/имената на колоната/колоните (Листинг \ref{listing0117}).

\subsection{Филтриране}

\section*{Заключение}

Подходящата предварителна обработка на данните за извършване на статистически анализ е ключова стъпка от процеса. В практиката това често налага групиране по признаци, филтриране по зададен критерии или итеративно обхождане и манипулация по зададени условия. Доброто разбиране и ефективната предварителна обработка на данните води до ясни и разбираеми резултати в следствие на статистическия анализ. 

