\newpage
\chapter{Групиране и обхождане на данни}
\label{chapter06}
\thispagestyle{empty}

Практиката показва, че около 80\% от статистическия анализ е манипулация на данните. Това често налага повтарящи се операции върху различни участъци от данните. Данните се разделят на отделни фрагменти, след това върху определени фрагменти се прилагат определени операции и накрая фрагментите се обединяват в едно цяло.

\section{Фамилията функции apply}

Фамилията функции apply служи за групово манипулиране на данни\index{групово манипулиране на данни}. Тъй като има различни входно-изходни комбинации на данните, то в R е представена цяла фамилия функции, а не една единствена.

\subsection{apply}

Функцията apply е първата, която потребителите научават и тя идва с най-много ограничения. Функцията се прилага върху матрици, което означава, че всичките елементи в матрицата трябва да са от един и същи тип. Ако функцията бъде приложена върху друг тип обект, то първо данните ще бъдат преобразувани до матрица. Първият аргумент при извикването е обекта, който ще бъде обработван. Вторият аргумент определя дали да се работи по редове (стойност 1) или по колони (стойност 2). Третият аргумент е функцията, която трябва да се приложи. Аргументите след третия могат да са променлив брой и се предават на функцията, която е посочена в третия аргумент.

\begin{lstlisting}[caption=Сума по редове и колони, label=listing0093]
m1 <- matrix(11:19, nrow=3)
m1
     [,1] [,2] [,3]
[1,]   11   14   17
[2,]   12   15   18
[3,]   13   16   19
 
apply(m1, 1, sum)
[1] 42 45 48
 
apply(m1, 2, sum)
[1] 36 45 54

m1[2,2] <- NA
m1
     [,1] [,2] [,3]
[1,]   11   14   17
[2,]   12   NA   18
[3,]   13   16   19

apply(m1, 1, sum)
[1] 42 NA 48

apply(m1, 2, sum)
[1] 36 NA 54

apply(m1, 1, sum, na.rm=TRUE)
[1] 42 30 48

apply(m1, 2, sum, na.rm=TRUE)
[1] 36 30 54
\end{lstlisting}

Едно от най-лесните пресмятания, за илюстрация на функцията apply, е сумата на елементите по редове и по колони в една матрица (Листинг \ref{listing0093}). Когато в матрицата има неопределени стойности (NA), подадената функция изчислява стойността до NA. Това поведение може да бъде променено, чрез игнориране на липсващите стойности, с подаване на параметъра na.rm=TRUE.

\subsection{lapply и sapply}

Функцията lapply получава като аргумент списък и връща като резултат списък (Листинг \ref{listing0094}). 

\begin{lstlisting}[caption=Сума на обекти в списък, label=listing0094]
l1 <- list(m2=matrix(1:9,3), l2=1:5, m3=matrix(1:4,2), n1=2)
l1
$m2
     [,1] [,2] [,3]
[1,]    1    4    7
[2,]    2    5    8
[3,]    3    6    9

$l2
[1] 1 2 3 4 5

$m3
     [,1] [,2]
[1,]    1    3
[2,]    2    4

$n1
[1] 2

lapply(l1, sum)
$m2
[1] 45

$l2
[1] 15

$m3
[1] 10

$n1
[1] 2

sapply(l1, sum)
m2 l2 m3 n1 
45 15 10  2
\end{lstlisting}

Ако върнатата стойност трябва да бъде вектор, то вместо lapply се използва sapply, която във всяко друго отношение работи като lappy.

\subsection{mapply}

Функцията mapply се ползва за прилагане на функция върху всеки елемент от множество списъци (Листинг \ref{listing0095}). 
\begin{lstlisting}[caption=Проверка за идентичност на елементите, label=listing0095]
l3 <- list(m4=matrix(1:25,5), m5=matrix(1:16,2), l4=1:5)
l5 <- list(m6=matrix(1:25,5), m7=matrix(1:16,8), l6=15:1)

mapply(identical, l3, l5)
   m4    m5    l4 
 TRUE FALSE FALSE

mapply(f1<-function(x,y){NROW(x)+NROW(y)}, l3, l5)
m4 m5 l4 
10 10 20 
\end{lstlisting}

Също така, mapply позволява и потребителски дефинирани функции.

\subsection{Агрегация}

При употребата на SQL е много популярно данните да се групират по признак/признаци и върху тях да бъдат изпълнявани агрегатни функции\index{агрегатни функции}. Един от начините да се постигне агрегация в R е, чрез функцията aggregate и синтаксиса за запис на формула. Формулите се записват с лява част и дясна част, отделени със символа тилда (\textasciitilde). От лявата страна стои променливата, по която ще се извършва пресмятането, а от дясната страна стои променлива (или група променливи), по която ще се извършва групирането.

\begin{lstlisting}[caption=Групиране на данни, label=listing0096]
data(diamonds, package="ggplot2")
head(diamonds, n=3)
  carat     cut color clarity depth table price    x    y    z
1  0.23   Ideal     E     SI2  61.5    55   326 3.95 3.98 2.43
2  0.21 Premium     E     SI1  59.8    61   326 3.89 3.84 2.31
3  0.23    Good     E     VS1  56.9    65   327 4.05 4.07 2.31

aggregate(price~cut, diamonds, mean)
        cut    price
1      Fair 4358.758
2      Good 3928.864
3 Very Good 3981.760
4   Premium 4584.258
5     Ideal 3457.542
\end{lstlisting}

Като пример за групиране и използване на агрегатна функция може да се изпълни пресмятането на средна цена за диамант, организирано в групи според вида на среза (Листинг \ref{listing0096}). Първият аргумент на функцията е формулата за групиране, вторият аргумент е обекта с данните, а третият аргумент е функцията, която се прилага върху отделните групи. Тъй като вторият аргумент показва кое множество данни се използва, то във формулата не е нужно да се указва множеството, а може да се използват директно имената на колоните. След третия аргумент могат да се добавят и други аргументи, като например na.rm=TRUE.

\begin{lstlisting}[caption=Групиране по повече от една колона, label=listing0097]
aggregate(price~cut+color, diamonds, mean)
         cut color    price
1       Fair     D 4291.061
2       Good     D 3405.382
3  Very Good     D 3470.467
4    Premium     D 3631.293
5      Ideal     D 2629.095
6       Fair     E 3682.312
7       Good     E 3423.644
8  Very Good     E 3214.652
9    Premium     E 3538.914
10     Ideal     E 2597.550
...
\end{lstlisting}

Както в SQL, така и при групирането в R е възможно групирането да се извърши по повече от една колона (Листинг \ref{listing0097}).

\begin{lstlisting}[caption=Прилагане на агрегатна функция върху повече колони в едни и същи групи, label=listing0098]
aggregate(cbind(price,carat)~cut, diamonds, mean)
        cut    price     carat
1      Fair 4358.758 1.0461366
2      Good 3928.864 0.8491847
3 Very Good 3981.760 0.8063814
4   Premium 4584.258 0.8919549
5     Ideal 3457.542 0.7028370
\end{lstlisting}

Възможно е агрегатната функция да бъде приложена върху повече от една колона, като това се постига с функцията cbind (Листинг \ref{listing0098}). Особеността при това извикване е, че само една агрегатна функция може да се приложи и всички избрани колони ще бъдат пресметнати спрямо нея (в случая се изчислява средна стойност).

\begin{lstlisting}[caption=Използване на повече колони от двете страни на формулата, label=listing0099]
aggregate(cbind(price,carat)~cut+color, diamonds, mean)
         cut color    price     carat
1       Fair     D 4291.061 0.9201227
2       Good     D 3405.382 0.7445166
3  Very Good     D 3470.467 0.6964243
4    Premium     D 3631.293 0.7215471
5      Ideal     D 2629.095 0.5657657
6       Fair     E 3682.312 0.8566071
7       Good     E 3423.644 0.7451340
8  Very Good     E 3214.652 0.6763167
9    Premium     E 3538.914 0.7177450
10     Ideal     E 2597.550 0.5784012
...
\end{lstlisting}

Изпълнението на агрегатни функции позволява да има повече от една колона и от двете страни на формулата (Листинг \ref{listing0099}). При използването на функцията за агрегация трябва да се има предвид, че тя може да бъде много бавна по отношение на изпълнението, особено при данни с голям обем.

\section{Пакетът plyr}

Пакетът plyr дава допълнителни възможности по схемата за обработка на данни разделяне-манипулиране-обединение. Ядрото на пакета се състои от функциите ddply, llply и ldply. При тези функции е използвана конвенция, която подсказва какъв е типа на входните данни и типа на изходните данни (в по-широката ѝ употреба това е унгарската нотация \cite{hnot}). Първата буква определя входния тип данни, а втората буква определя изходния тип данни. Буквата d се използва за data.frame, буквата l за списък, буквата a за масив, а символът за подчертаване (\_) се използва при липса на върната стойност.

\subsection{ddply}

За илюстрация на функцията ddply е удачно да се използват данните за бейзболни резултати от пакета plyr (Листинг \ref{listing0100}).

\begin{lstlisting}[caption=Бейзболна статистика, label=listing0100]
library( plyr )

head(baseball,n=3)
          id year stint team lg  g  ab  r  h X2b X3b hr rbi sb cs bb so ibb
4  ansonca01 1871     1  RC1    25 120 29 39  11   3  0  16  6  2  2  1  NA
44 forceda01 1871     1  WS3    32 162 45 45   9   4  0  29  8  0  4  0  NA
68 mathebo01 1871     1  FW1    19  89 15 24   3   1  0  10  2  1  2  0  NA
   hbp sh sf gidp
4   NA NA NA   NA
44  NA NA NA   NA
68  NA NA NA   NA
\end{lstlisting}

В това множество данни са отчетени 21699 записа в бейзболната статистика за 1228 играча, в диапазона от годините 1871 до 2007. Включени са само играчи с 15 или повече сезона игра. В множеството се отчитат 22 признака (колони), със следното значение:

\begin{table}[h!]
\centering
\begin{tabular}{|l|r|} 
  \rowcolor{lightgray}
  \hline
  Характеристика & Значение \\ [0.1ex] 
  \hline\hline
  id & Идентификатор на играча (символен низ) \\
  \hline
  year & Година на събраните данни (цяло число) \\
  \hline
  stint & Ограничения (цяло число) \\
  \hline
  team & Отбор, в който играе (символен низ) \\
  \hline
  lg & Лига, в която играе (символен низ) \\
  \hline
  g & Брой игри (цяло число) \\
  \hline
  ab & Брой батирания (цяло число) \\
  \hline
  r & Брой пробягвания (цяло число) \\
  \hline
  h & Брой реализирани удари (цяло число) \\
  \hline
  X2b & Брой успешни достигания до втора база (цяло число) \\
  \hline
  X3b & Брой успешни достигания до трета база (цяло число) \\
  \hline
  hr & Брой успешни хоум ръна (цяло число) \\
  \hline
  rbi & Брой тичания, в които е удрял (цяло число) \\
  \hline
  sb & Брой откраднати бази (цяло число) \\
  \hline
  cs & Брой хванати отнемания (цяло число) \\
  \hline
  bb & Брой пробягвания (цяло число) \\
  \hline
  so & Брой изхвърлени изстрели (цяло число) \\
  \hline
  ibb & Брой международни пробягвания (цяло число) \\
  \hline
  hbp & Брой попадения от питчъра (цяло число) \\
  \hline
  sh & Брой пожертвани удари (цяло число) \\
  \hline
  sf & Брой пожертвани изстрела (цяло число) \\
  \hline
  gidp & Брой приземявания при двойна игра (цяло число) \\
  \hline
\end{tabular}
\caption{Характеристики на бейзболните играчи}
\label{table0003}
\end{table}

Основна статистика в бейзбола е OBP (On Base Percentage), която се изчислява по формула \ref{equation0001}.

\begin{equation}
OBP = \frac{H + BB + HBP}{AB + BB + HBP + SF}
\label{equation0001}
\end{equation}
\listofequations{On Base Percentage (OBP) статистика}

Където:
H – брой удари,
BB – пробягвания,
HBP – брой попадения от питчъра,
AB – удари на батата,
SF – пропуснати изстрели.

Преди 1954 година, за SF стойностите са 0, поради различния начин за отчитане на статистиката. В данните има множество NA стойности за HBP. Липсващите стойности трябва да се заменят с 0. От множеството данни се изключват и всички редове, за които AB е по-малко от 50 (Листинг \ref{listing0101}).

\begin{lstlisting}[caption=Корекция на данните, label=listing0101]
any( is.na(baseball$sf) )
[1] TRUE

baseball$sf[baseball$year < 1954] <- 0

any( is.na(baseball$sf) )
[1] FALSE

any( is.na(baseball$hbp) )
[1] TRUE
 
baseball$hbp[ is.na(baseball$hbp) ] <- 0
 
any( is.na(baseball$hbp) )
[1] FALSE

baseball <- baseball[baseball$ab>=50,]
\end{lstlisting}

Пресмятането на коефициента OBP за всеки играч, за конкретна година е изключително лесно, поради възможността да се изпълни векторно пресмятане (Листинг \ref{listing0102}).

\begin{lstlisting}[caption=Пресмятане на OBP, label=listing0102]
baseball$OBP <- with(baseball, (h+bb+hbp)/(ab+bb+hbp+sf))

head(cbind(baseball$id,baseball$OBP), n=3)
     [,1]        [,2]               
[1,] "ansonca01" "0.336065573770492"
[2,] "forceda01" "0.295180722891566"
[3,] "mathebo01" "0.285714285714286"
\end{lstlisting}


Функцията with позволява да се упомене обекта с данните само един път, а в следващите аргументи да се използват само имената на колоните, без да се уточнява на кое множество данни принадлежат.

OBP коефициента за цялата кариера на играча не може да се пресметне чрез просто усредняване на сезонния OBP коефициент. Трябва да се пресметне и сумира числителят и след това да се раздели на сумата в делителя. Това може да се постигне с функцията ddply (Листинг \ref{listing0103}).

\begin{lstlisting}[caption=Пресмятане на OBP за цялата кариера на играча, label=listing0103]
career <- ddply(baseball, .variables="id", .fun=function(data){c(OBP=with(data,sum(h+bb+hbp)/sum(ab+bb+hbp+sf)))})

career <- career[order(career$OBP,decreasing=TRUE), ]

head(career, n=3)
            id       OBP
1089 willite01 0.4816861
875   ruthba01 0.4742209
658  mcgrajo01 0.4657478
\end{lstlisting}

Вградената потребителска функция извършва пресмятането, а след това ddply изпълнява пресмятането върху всеки играч. Полученият резултат е сортиран в низходящ ред, според кариерния OBP коефициент.

\subsection{llply}

Функцията llply може да бъде използвана по аналогичен начин, както се използва функцията lapply (Листинг \ref{listing0104}).

\begin{lstlisting}[caption=Сума на всеки елемент в списък, label=listing0104]
l1 <- list(m2=matrix(1:9,3), l2=1:5, m3=matrix(1:4,2), n1=2)

llply(l1, sum)
$m2
[1] 45

$l2
[1] 15

$m3
[1] 10

$n1
[1] 2

identical(lapply(l1,sum), llply(l1,sum))
[1] TRUE

laply(l1, sum)
[1] 45 15 10  2
\end{lstlisting}

Функцията laply извършва същото пресмятане, но връща резултата под формата на вектор.

\subsection{Помощни функции и бързодействие}

В пакета plyr са добавени група помощни функции, като функцията each, която позволява да се изпращат повече от една агрегатна функция на функцията aggregate (Листинг \ref{listing0105}). Недостатък на each е, че тя отнема възможността за изпращане на допълнителни параметри.

\begin{lstlisting}[caption=Повече от една агрегатна функция, label=listing0105]
library(ggplot2)

aggregate(price~cut, diamonds, each(mean, median))
        cut price.mean price.median
1      Fair   4358.758     3282.000
2      Good   3928.864     3050.500
3 Very Good   3981.760     2648.000
4   Premium   4584.258     3185.000
5     Ideal   3457.542     1810.000
\end{lstlisting}

Друга полезна функция е idata.frame, която позволява създаването на референция към data.frame, така че формирането на подмножества да става по-бързо и при значително по-ниска консумация на оперативна памет (Листинг \ref{listing0106}). 

\begin{lstlisting}[caption=Бързодействие при използване на референции, label=listing0106]
system.time(dlply(baseball, "id", nrow))
   user  system elapsed 
  0.159   0.009   0.169 

reference <- idata.frame( baseball )

system.time(dlply(reference, "id", nrow))
   user  system elapsed 
  0.178   0.005   0.183
\end{lstlisting}

Ускорението, което ще се постигне, много зависи от размера на данните и от вида на пресмятането, което се извършва над тях. Пакетът plyr често води до компромис с бързодействието в замяна на по-голямо удобство при пресмятането. Повечето функции в пакета може да се изпълнят и с функции от базовата инсталация, plyr просто дава по-удобен начин за пресмятане.

\section{Пакетът data.table}

Този пакет е създаден с идеята да увеличи възможностите за използване на data.frame структурата от данни. Пакетът изисква малко по-различен синтаксис за работа спрямо този, който вече е наложен при използването на data.frame. Бързодействието при data.table основно се дължи на това, че вътрешната реализация е аналогична на индексите при базите данни. Това позволява по-бърз достъп до данните, по-бързи операции за групиране и по-бързи операции за сливане (join).

\begin{lstlisting}[caption=Създаване на data.table, label=listing0107]
library(data.table)

df <- data.frame(x1=10:1, x2=letters[11:20], x3=LETTERS[1:10], x4=rep(c("One", "Two", "Three"), length.out=10))
 
df
   x1 x2 x3    x4
1  10  k  A   One
2   9  l  B   Two
3   8  m  C Three
4   7  n  D   One
5   6  o  E   Two
6   5  p  F Three
7   4  q  G   One
8   3  r  H   Two
9   2  s  I Three
10  1  t  J   One

class( df$x2 )
[1] "factor"

dt <- data.table(x1=10:1, x2=letters[11:20], x3=LETTERS[1:10], x4=rep(c("One", "Two", "Three"), length.out=10))
 
dt
    x1 x2 x3    x4
 1: 10  k  A   One
 2:  9  l  B   Two
 3:  8  m  C Three
 4:  7  n  D   One
 5:  6  o  E   Two
 6:  5  p  F Three
 7:  4  q  G   One
 8:  3  r  H   Two
 9:  2  s  I Three
10:  1  t  J   One

class( dt$x2 )
[1] "character"
\end{lstlisting}

Създаването на data.table не се различава особено от създаването на data.frame (Листинг \ref{listing0107}). Зареждането на данни е идентично с разликата, че data.frame преобразува символните низове до фактори, докато data.table ги запазва като символни низове.

\begin{lstlisting}[caption=Зареждане на data.table от data.frame, label=listing0108]
diamonds <- data.table(diamonds)

diamonds
       carat       cut color clarity depth table price    x    y    z
    1:  0.23     Ideal     E     SI2  61.5    55   326 3.95 3.98 2.43
    2:  0.21   Premium     E     SI1  59.8    61   326 3.89 3.84 2.31
    3:  0.23      Good     E     VS1  56.9    65   327 4.05 4.07 2.31
    4:  0.29   Premium     I     VS2  62.4    58   334 4.20 4.23 2.63
    5:  0.31      Good     J     SI2  63.3    58   335 4.34 4.35 2.75
   ---                                                               
53936:  0.72     Ideal     D     SI1  60.8    57  2757 5.75 5.76 3.50
53937:  0.72      Good     D     SI1  63.1    55  2757 5.69 5.75 3.61
53938:  0.70 Very Good     D     SI1  62.8    60  2757 5.66 5.68 3.56
53939:  0.86   Premium     H     SI2  61.0    58  2757 6.15 6.12 3.74
53940:  0.75     Ideal     D     SI2  62.2    55  2757 5.83 5.87 3.64
\end{lstlisting}

Създаването на data.table от data.frame става, чрез просто извикване на функцията (Листинг \ref{listing0108}). При разпечатването на резултата има разлика в това, че се показват първите пет и последните пет реда от данните.

\begin{lstlisting}[caption=Достъп до редовете, label=listing0109]
dt[1:2, ]
   x1 x2 x3  x4
1: 10  k  A One
2:  9  l  B Two

dt[dt$x1>=7, ]
   x1 x2 x3    x4
1: 10  k  A   One
2:  9  l  B   Two
3:  8  m  C Three
4:  7  n  D   One

dt[x1>=7, ]
   x1 x2 x3    x4
1: 10  k  A   One
2:  9  l  B   Two
3:  8  m  C Three
4:  7  n  D   One
\end{lstlisting}

Достъпът до редовете се осъществява по аналогичен начин, както е при data.frame (Листинг \ref{listing0109}). Третото позоваване е възможно, тъй като data.table знае как да открие нужната колона и без да е указана точната data.table променлива.

\begin{lstlisting}[caption=Достъп до колоните, label=listing0110]
dt[,list(x3,x4)]
    x3    x4
 1:  A   One
 2:  B   Two
 3:  C Three
 4:  D   One
 5:  E   Two
 6:  F Three
 7:  G   One
 8:  H   Two
 9:  I Three
10:  J   One

dt[, x1]
 [1] 10  9  8  7  6  5  4  3  2  1

dt[,list(x2)]
    x2
 1:  k
 2:  l
 3:  m
 4:  n
 5:  o
 6:  p
 7:  q
 8:  r
 9:  s
10:  t

dt[, "x4", with=FALSE]
       x4
 1:   One
 2:   Two
 3: Three
 4:   One
 5:   Two
 6: Three
 7:   One
 8:   Two
 9: Three
10:   One

td[, c("x2", "x3"), with=FALSE]
    x2 x3
 1:  k  A
 2:  l  B
 3:  m  C
 4:  n  D
 5:  o  E
 6:  p  F
 7:  q  G
 8:  r  H
 9:  s  I
10:  t  J
\end{lstlisting}

Достъпът до колоните се осъществява малко по-различно спрямо data.frame (Листинг \ref{listing0110}). За да се позоват колоните като символни низове (примерно получени след някакво пресмятане), трябва да се подаде лъжа на параметъра with.

\subsection{Ключове}

При наличие на няколко таблици в паметта, то с тях може да се изпълнят серия операции. Като начало, списък с наличните таблици може да се получи чрез функцията tables (Листинг \ref{listing0111}).

\begin{lstlisting}[caption=Операции с таблици, label=listing0111]
tables()
       NAME   NROW NCOL MB                                    COLS KEY
1: diamonds 53,940   10  3 carat,cut,color,clarity,depth,table,...    
2:       dt     10    4  0                             x1,x2,x3,x4    
Total: 3MB

setkey(dt, x4)

dt
    x1 x2 x3    x4
 1: 10  k  A   One
 2:  7  n  D   One
 3:  4  q  G   One
 4:  1  t  J   One
 5:  8  m  C Three
 6:  5  p  F Three
 7:  2  s  I Three
 8:  9  l  B   Two
 9:  6  o  E   Two
10:  3  r  H   Two

tables()
       NAME   NROW NCOL MB                                    COLS KEY
1: diamonds 53,940   10  3 carat,cut,color,clarity,depth,table,...    
2:       dt     10    4  0                             x1,x2,x3,x4  x4
Total: 3MB

key( dt )
[1] "x4"

dt["One", ]
   x1 x2 x3  x4
1: 10  k  A One
2:  7  n  D One
3:  4  q  G One
4:  1  t  J One

dt[c("One","Two"), ]
   x1 x2 x3  x4
1: 10  k  A One
2:  7  n  D One
3:  4  q  G One
4:  1  t  J One
5:  9  l  B Two
6:  6  o  E Two
7:  3  r  H Two

setkey(diamonds, cut, color)

diamonds
       carat   cut color clarity depth table price    x    y    z
    1:  0.75  Fair     D     SI2  64.6    57  2848 5.74 5.72 3.70
    2:  0.71  Fair     D     VS2  56.9    65  2858 5.89 5.84 3.34
    3:  0.90  Fair     D     SI2  66.9    57  2885 6.02 5.90 3.99
    4:  1.00  Fair     D     SI2  69.3    58  2974 5.96 5.87 4.10
    5:  1.01  Fair     D     SI2  64.6    56  3003 6.31 6.24 4.05
   ---                                                           
53936:  0.71 Ideal     J     SI1  60.6    57  2700 5.78 5.83 3.52
53937:  0.81 Ideal     J     VS2  62.1    56  2708 5.92 5.97 3.69
53938:  0.84 Ideal     J     VS2  61.1    57  2709 6.09 6.12 3.73
53939:  0.82 Ideal     J     VS2  61.6    56  2741 6.00 6.04 3.71
53940:  0.83 Ideal     J     VS2  62.3    55  2742 6.01 6.03 3.75

diamonds[J("Fair", "J"), ]
     carat  cut color clarity depth table price    x    y    z
  1:  1.05 Fair     J     SI2  65.8    59  2789 6.41 6.27 4.18
  2:  1.00 Fair     J     VS2  65.7    59  2811 6.14 6.07 4.01
  3:  0.99 Fair     J     SI1  55.0    61  2812 6.72 6.67 3.68
  4:  0.90 Fair     J     VS2  65.0    56  2815 6.08 6.04 3.94
  5:  0.91 Fair     J     VS2  64.4    62  2854 6.06 6.03 3.89
 ---                                                          
115:  0.90 Fair     J     SI1  64.6    61  2438 5.92 5.87 3.81
116:  0.96 Fair     J     SI1  67.3    56  2517 6.06 6.01 4.06
117:  0.90 Fair     J     SI2  66.6    54  2536 6.05 5.99 4.01
118:  0.97 Fair     J     SI2  60.8    67  2538 6.41 6.32 3.87
119:  1.01 Fair     J     SI2  66.9    58  2683 6.13 6.07 4.08
\end{lstlisting}

Както се вижда, нито една от таблиците няма присвоен ключ\index{ключови полета}. Ключът е индексирана колона, която дава допълнително бързодействие при извършването на някои операции. При наличие на ключово поле е възможно изборът на редове да става и чрез подаване на стойности от ключовото поле. Ключът може да бъде и съставен, ако съдържа повече от едно поле. Функцията J служи за достъп до редовете според стойности на съставния ключ.

\subsection{Агрегация}

Основното предимство на индексираните данни е бързодействието при изпълнението на агрегатни функции\index{агрегатни функции}. Въпреки че aggregate и фамилията функции d*ply работят с data.table обекти (Листинг \ref{listing0112}), то използването им е свързано с бавно изпълнение.

\begin{lstlisting}[caption=Агрегатни функции, label=listing0112]
aggregate(price~cut, diamonds, mean)
        cut    price
1      Fair 4358.758
2      Good 3928.864
3 Very Good 3981.760
4   Premium 4584.258
5     Ideal 3457.542

diamonds[, list(price=mean(price)), by=cut]
         cut    price
1:      Fair 4358.758
2:      Good 3928.864
3: Very Good 3981.760
4:   Premium 4584.258
5:     Ideal 3457.542

diamonds[, list(price=mean(price)), by=list(cut,color)]
          cut color    price
 1:      Fair     D 4291.061
 2:      Fair     E 3682.312
 3:      Fair     F 3827.003
 4:      Fair     G 4239.255
 5:      Fair     H 5135.683
 6:      Fair     I 4685.446
 7:      Fair     J 4975.655
...
29:     Ideal     D 2629.095
30:     Ideal     E 2597.550
31:     Ideal     F 3374.939
32:     Ideal     G 3720.706
33:     Ideal     H 3889.335
34:     Ideal     I 4451.970
35:     Ideal     J 4918.186
          cut color    price

diamonds[, list(price=mean(price),carat=sum(carat)), by=list(cut,color)]
          cut color    price   carat
 1:      Fair     D 4291.061  149.98
 2:      Fair     E 3682.312  191.88
 3:      Fair     F 3827.003  282.27
 4:      Fair     G 4239.255  321.48
 5:      Fair     H 5135.683  369.41
 6:      Fair     I 4685.446  209.66
 7:      Fair     J 4975.655  159.60
...
29:     Ideal     D 2629.095 1603.38
30:     Ideal     E 2597.550 2257.50
31:     Ideal     F 3374.939 2509.20
32:     Ideal     G 3720.706 3422.29
33:     Ideal     H 3889.335 2490.52
34:     Ideal     I 4451.970 1910.97
35:     Ideal     J 4918.186  952.98
          cut color    price   carat
\end{lstlisting}

По-добрият вариант е да се използват вградените в data.table агрегатни функции. За да бъде агрегацията по повече от една колона, то нужните колони се подават като списък. За разлика от предишната агрегация, тук могат да се подават различни агрегатни функции (средна и сума, в показания пример), както и да се ползват списък от колони за групиране и за агрегиране.

\section{Бързи операции с пакета dplyr}

Пакетът dplyr е създаден основно с идеята за ускорение на изпълнението, спрямо бързодействието постигнато в пакета plyr. Пакетът dplyr основно борави с обекти от тип data.frame, а за списъци и вектори е предназначен пакетът purrr. Характерно за dplyr е, че използва названия на някои от функциите, които са добре познати в езика SQL.

Когато се работи едновременно с пакетите plyr и dplyr е важен редът на зареждането им, тъй като последно заредения пакет в R е с приоритет, при наличие на едноименни функции. При колизия на имената конфликтът се разрешава чрез операцията за принадлежност\index{обсег на видимост} към пакет (::), като от лявата страна е името на пакета, а от дясната страна името на функцията. Пример за такава колизия е функцията за обобщение на данните в двата пакета - plyr::summarize и dplyr::summarize.

\subsection{Потоци и таблици}

Концепцията за потоците\index{потоци} (pipes) е развита още с първите масово използвани операционни системи, а в езика R тя е възможна благодарение на пакета magrittr. При класическата работа с функции, резултатът от извикването на първата функция се записва в междинна променлива, тази променлива се подава като аргумент на втората функция, която на свой ред записва във втора междинна променлива и този процес може да се повтаря многократно. Потоците позволяват да се избегне използването на междинни променливи, а използването на функциите да се организира като една верига от извиквания (Листинг \ref{listing0113}). Синтаксисът за поточна операция\index{поточни операции} в R е два символа за процент и знакът за по-голямо между тях (\%>\%).

\begin{lstlisting}[caption=Поточни операции, label=listing0113]
library( ggplot2 )
library( magrittr )
 
dim( head(diamonds,n=4) )
[1]  4 10
 
diamonds %>% head(4) %>% dim
[1]  4 10
\end{lstlisting}

С поточната операция се подава обекта, като първи аргумент на съответната функция. Поточните операции могат да се навързват във верига и обектът в резултат от изпълнението на една функция да се предава към следваща.

По аналогия с обектите от тип data.table, пакетът dplyr предлага разширение на data.frame под формата на tbl обекти, които се доразвиват и в пакета tibble. Съществено за tbl е, че при разпечатване се показват само подмножество на редовете, но също и подмножество на колоните, докато бъде изпълнен екрана. Третата разлика е, че под имената на колоните се визуализира информация за типът данни в колоната. При по-новите реализации на пакета ggplot2, данните за диамантите са представени и като tbl обект (Листинг \ref{listing0114}).

\begin{lstlisting}[caption=Таблични данни в dplyr, label=listing0114]
class( diamonds )
[1] "tbl_df"     "tbl"        "data.frame"

head(diamonds, n=3)
# A tibble: 3 x 10
  carat cut     color clarity depth table price     x     y     z
  <dbl> <ord>   <ord> <ord>   <dbl> <dbl> <int> <dbl> <dbl> <dbl>
1  0.23 Ideal   E     SI2      61.5    55   326  3.95  3.98  2.43
2  0.21 Premium E     SI1      59.8    61   326  3.89  3.84  2.31
3  0.23 Good    E     VS1      56.9    65   327  4.05  4.07  2.31
\end{lstlisting}

\subsection{Извличане по колони}

По аналогия с SQL, функцията select извършва подбор на редове от зададено множество данни\index{извличане на данни по колони} (Листинг \ref{listing0115}). Първият аргумент е data.frame (или tbl обект), а следващите аргументи изброяват желаните колони. Функцията може да се използва самостоятелно или с потоци.

\begin{lstlisting}[caption=Избор на редове, label=listing0115]
library( dplyr )

select(diamonds, carat, price)
diamonds %>% select(carat, price)
diamonds %>% select(c(carat, price))

diamonds %>% select_('carat', 'price')
names <- c('carat', 'price')
diamonds %>% select_(.dots=names)

diamonds %>% select( one_of('carat', 'price') )
names <- c('carat', 'price')
diamonds %>% select( one_of(names) )

select(diamonds, 1, 7)
diamonds %>% select(1, 7)
\end{lstlisting}

Функцията select позволява извикване по множество различни начини, които могат да доведат до един и същи начин. Като аргументи, select получава директно имената на колоните, без те да са обградени в кавички (тоест не са символни низове). Когато е нужно имената на колоните да се подават като символни низове се използва функцията select\_, която се различава в името си с една подчертавка в края. Ако имената на колоните са запазени в променлива то те се подават на .dots параметъра. От версия 0.6.0 на пакета dplyr не се препоръчва използването на функцията select\_, а заместването ѝ с функцията select и аргумент върнат, като стойност от функцията one\_of. На функцията select освен имена на колони, може да се подават и техните индекси.

\begin{lstlisting}[caption=Търсене по частично съвпадение, label=listing0116]
diamonds %>% select( starts_with('c') )
diamonds %>% select( ends_with('e') )
diamonds %>% select( contains('l') )

diamonds %>% select( matches('r.+t') )
\end{lstlisting}

Понякога в практиката се налага подбор на колони в множеството от данни по критерии за частично съвпадение (Листинг \ref{listing0116}). При такава ситуация за начало се ползва функцията starts\_with, за край функцията ends\_with, а за съдържание функцията contains. При частичния избор е възможно да се използват и регулярни изрази.

\begin{lstlisting}[caption=Изключване на колони, label=listing0117]
diamonds %>% select(-carat, -price)
diamonds %>% select( -c(carat, price) )
diamonds %>% select(-1, -7)
diamonds %>% select( -c(1,7) )
diamonds %>% select_(.dots=c('-carat', '-price'))
diamonds %>% select( -one_of('carat','price') )
\end{lstlisting}

В някои ситуации от множеството колони трябва да се изключат една част. Това се постига със записване на знак минус пред името/имената на колоната/колоните (Листинг \ref{listing0117}).

\subsection{Филтриране}

Филтрирането\index{филтриране на редове} се състои в избиране на редове от данните по зададен критерии (логически израз).

\begin{lstlisting}[caption=Филтриране на редове, label=listing0118]
library( ggplot2 )
library( magrittr )
library( dplyr )

diamonds %>% filter(cut == 'Ideal')
diamonds[diamonds$cut == 'Ideal', ]

diamonds %>% filter(cut %in% c('Ideal', 'Good'))

diamonds %>% filter(carat > 2, price < 14000)
diamonds %>% filter(carat > 2 & price < 14000)

diamonds %>% filter(carat < 1 | carat > 5)

diamonds %>% filter_("cut == 'Ideal'")
diamonds %>% filter_(~cut == 'Ideal')
cut <- 'Ideal'
diamonds %>% filter_(~cut == cut)

col <- 'cut'
cut <- 'Ideal'
diamonds %>% filter_(sprintf("%s == '%s'", col, cut))
\end{lstlisting}

Възможно е да се направи филтриране с поточните операции, но също така и с базовия синтаксис на езика R (Листинг \ref{listing0118}). За да се извърши филтриране по повече от една стойност се използва операцията \%in\%. При филтрирането може да се използват всички стандартни операции за сравнение. При отделяне на повече от един израз със запетая (,) или амперсанд (\&) се изпълнява филтриране, за което и всички условия трябва да се изчислят до стойност TRUE. Филтри с логическо ИЛИ се конструират с операцията вертикална черта (|)\index{логически операции}.

Ако имената на колоните трябва да се зададат със символни низове, то вместо функцията filter се използва функцията filter\_. Пред израза се поставя тилда (\~). Едновременното представяне като символен низ на желаната стойност за филтриране и името на колоната, по която ще се филтрира, изисква малко повече усилия и може да се постигне с функцията за обработка на символни низове sprintf.

\begin{lstlisting}[caption=Избор по индекси, label=listing0119]
diamonds %>% slice(1:5)
diamonds %>% slice(c(1:5, 8, 15:20))
diamonds %>% slice(-1)
\end{lstlisting}

Освен филтриране по логически израз е възможно избирането на редове по зададени индекси. За тази цел се ползва функцията slice (Листинг \ref{listing0119}). Индексите могат да се подадат под формата на вектор. Когато индексите са отрицателни, това означава, че тези редове няма да бъдат част от върнатия резултат.

\subsection{Модификация, обобщение, групиране и подреждане}

Създаването или модифицирането на колони\index{модифициране на колони} в множеството от данни се извършва с функцията mutate (Листинг \ref{listing0120}). 

\begin{lstlisting}[caption=Модификация на колони, label=listing0120]
diamonds %>% mutate(price/carat)
diamonds %>% select(carat, price) %>% mutate(price/carat)
diamonds %>% select(carat, price) %>% mutate(ratio=price/carat)

diamonds %>% select(carat, price) %>% mutate(ratio=price/carat, square=ratio*ratio)
\end{lstlisting}

Добавянето на съотношение цена/карати се извършва с подаване на израза, като параметър на функцията mutate. На новосъздадената колона може да се сложи и име, което стои от лявата страна на знака за присвояване, когато се подава като аргумент на функцията mutate. Новосъздадените колони могат да се използват веднага, още в самото извикване на функцията mutate.

Добавянето на колона не модифицира оригиналното множество данни. За да се отразят промените, то новосъздаденото множество трябва да бъде присвоено на съответната променлива. Пакетът magrittr предоставя двупосочна поточна операция\index{поточни операции} (\%<>\%). С двупосочната поточна операция промените направени от дясната страна на операцията се отразяват на обекта от лявата страна на операцията (Листинг \ref{listing0121}). 

\begin{lstlisting}[caption=Отразяване на модификациите, label=listing0121]
diamonds2 <- diamonds

diamonds2 %<>% select(carat, price) %>% mutate(ratio=price/carat, square=ratio*ratio)

head(diamonds2, n=3)
# A tibble: 3 x 4
  carat price ratio   square
  <dbl> <int> <dbl>    <dbl>
1  0.23   326 1417. 2008998.
2  0.21   326 1552. 2409887.
3  0.23   327 1422. 2021342.
\end{lstlisting}

Докато функцията mutate изпълнява определена операция върху стойностите в една колона, то функцията summarize\index{обобщение по колони} (Листинг \ref{listing0122}) връща един обект, който обобщава резултатите от една функция (например mean, max, min, median и други).

\begin{lstlisting}[caption=Обобщаваща информация, label=listing0122]
summarize(diamonds, sd(price))
diamonds %>% summarize(sd(price))
# A tibble: 1 x 1
  `sd(price)`
        <dbl>
1       3989.

diamonds %>% summarize(AveragePrice=mean(price), MedianPrice=median(price), AverageCarat=mean(carat))
# A tibble: 1 x 3
  AveragePrice MedianPrice AverageCarat
         <dbl>       <dbl>        <dbl>
1        3933.        2401        0.798
\end{lstlisting}

Удобното при функцията summarize е, че тя позволява изчисление по няколко различни агрегатни функции и също така позволява да се зададат имена на колоните.

\begin{lstlisting}[caption=Групиране при обобщение, label=listing0123]
diamonds %>% group_by(cut, color) %>% summarize(AveragePrice=mean(price), SumCarat=sum(carat))
# A tibble: 35 x 4
# Groups:   cut [?]
   cut   color AveragePrice SumCarat
   <ord> <ord>        <dbl>    <dbl>
 1 Fair  D            4291.     150.
 2 Fair  E            3682.     192.
 3 Fair  F            3827.     282.
 4 Fair  G            4239.     321.
 5 Fair  H            5136.     369.
 6 Fair  I            4685.     210.
 7 Fair  J            4976.     160.
 8 Good  D            3405.     493.
 9 Good  E            3424.     695.
10 Good  F            3496.     705.
# ... with 25 more rows
\end{lstlisting}

Обобщението на информацията по колони е полезно само по себе си, но значително повече информация носи, когато обобщението е извършено по групи\index{групиране по редове} (Листинг \ref{listing0123}). При групирането може да се задават една или повече колони за групиране, а при обобщаването една или повече агрегатни функции.

\begin{lstlisting}[caption=Подредба на резултатите, label=listing0124]
diamonds %>% group_by(cut) %>% summarize(AveragePrice=mean(price), SumCarat=sum(carat)) %>% arrange(desc(SumCarat))
# A tibble: 5 x 3
  cut       AveragePrice SumCarat
  <ord>            <dbl>    <dbl>
1 Ideal            3458.   15147.
2 Premium          4584.   12301.
3 Very Good        3982.    9743.
4 Good             3929.    4166.
5 Fair             4359.    1684.
\end{lstlisting}

Подредбата на резултатите, след групиране и обобщение, се постига чрез функцията arrange (Листинг \ref{listing0124}). Ако бъде използвана функцията desc, то сортирането е в низходящ ред, ако не бъде използвана, по подразбиране, сортирането е във възходящ ред.

\subsection{Специфични изчисления и връзка с база данни}

За по-специфични изчисления, които не са предварително реализирани в пакета dplyr, съществува възможността за използване на функцията do (Листинг \ref{listing0125}).

\begin{lstlisting}[caption=Специфични изчисления, label=listing0125]
bottom <- function(x, N=5){ x %>% arrange(carat) %>% head(N) }
 
diamonds %>% group_by(cut) %>% do(bottom(., N=3))
# A tibble: 15 x 10
# Groups:   cut [5]
   carat cut       color clarity depth table price     x     y     z
   <dbl> <ord>     <ord> <ord>   <dbl> <dbl> <int> <dbl> <dbl> <dbl>
 1  0.22 Fair      E     VS2      65.1    61   337  3.87  3.78  2.49
 2  0.23 Fair      G     VVS2     61.4    66   369  3.87  3.91  2.39
 3  0.25 Fair      D     VS1      61.2    55   563  4.09  4.11  2.51
 4  0.23 Good      E     VS1      56.9    65   327  4.05  4.07  2.31
 5  0.23 Good      F     VS1      58.2    59   402  4.06  4.08  2.37
 6  0.23 Good      E     VS1      64.1    59   402  3.83  3.85  2.46
 7  0.2  Very Good E     VS2      63.4    59   367  3.74  3.71  2.36
 8  0.21 Very Good E     VS2      63.2    54   386  3.82  3.78  2.4 
 9  0.23 Very Good H     VS1      59.4    61   338  4     4.05  2.39
10  0.2  Premium   E     SI2      60.2    62   345  3.79  3.75  2.27
11  0.2  Premium   E     VS2      59.8    62   367  3.79  3.77  2.26
12  0.2  Premium   E     VS2      59      60   367  3.81  3.78  2.24
13  0.2  Ideal     E     VS2      59.7    55   367  3.86  3.84  2.3 
14  0.2  Ideal     D     VS2      61.5    57   367  3.81  3.77  2.33
15  0.2  Ideal     E     VS2      62.2    57   367  3.76  3.73  2.33
\end{lstlisting}

Функцията позволява да се изпълняват потребителски функции върху данните. Чрез комбинацията на do и group\_by се връщат най-долните N реда, сортирани по карати, за всяко подмножество от вид срязване на диамантите.

При използването на поточни операции, левият операнд на потока се явява първи аргумент на функцията от дясно. Тъй като в примера (Листинг \ref{listing0125}) от лявата страна на потока са данни, а не функция, то чрез операцията точка (.) се оказва мястото, на което данните трябва да бъдат използвани.

Голямо предимство на пакета dplyr е възможността му да обработва данни от база данни\index{бази данни}, по начин много подобен на работата с data.frame обекти. Пакетът работи с повечето популярни системи за управление на бази от данни, като PostgreSQL, MySQL, SQLite и други. Трябва да се има предвид, че операциите за работа с база данни са относително бавни и бързодействието на пакета е значително по-малко в сравнение с бързодействието постигано при data.fram обектите. Положителното на директната работа с база данни е, че при много големи обеми от данни би било неприемливо те да се зареждат в оперативната памет (или дори невъзможно).

\begin{lstlisting}[caption=Работа с база данни, label=listing0126]
setwd( "~/Desktop" )

download.file("https://github.com/TodorBalabanov/Statistical-Data-Processing-with-R/blob/master/data/diamonds.db?raw=true", destfile="./diamonds.db", mode="wb")

source <- src_sqlite("diamonds.db")
source
src:  sqlite 3.22.0 [/Users/todorbalabanov/Desktop/diamonds.db]
tbls: DiamondColors, diamonds, sqlite_stat1

table <- tbl(source, "diamonds")
table %>% head(3)
# Source:   lazy query [?? x 10]
# Database: sqlite 3.22.0 [/Users/todorbalabanov/Desktop/diamonds.db]
  carat cut     color clarity depth table price     x     y     z
  <dbl> <chr>   <chr> <chr>   <dbl> <dbl> <int> <dbl> <dbl> <dbl>
1  0.23 Ideal   E     SI2      61.5    55   326  3.95  3.98  2.43
2  0.21 Premium E     SI1      59.8    61   326  3.89  3.84  2.31
3  0.23 Good    E     VS1      56.9    65   327  4.05  4.07  2.31
\end{lstlisting}

За илюстриране на работата с бази данни, SQLite е изключително удобна възможност. За да може пакетът dplyr да работи е необходимо да бъде инсталиран и пакетът dbplyr, дори и да не е зареден в паметта. Като начало, определя се работната директория, в която ще се помести файла, съдържащ базата данни (Листинг \ref{listing0126}). Следва команда за изтеглянето на самия файл. Към изтегления файл се насочва променлива, която ще бъде използвана като източник на данните. След установяване връзка към базата е необходимо да се насочи променлива и към конкретна таблица. Макар и данните да изглеждат като data.frame, то те са таблица в база данни и повечето dplyr операции се извършват директно върху данните в базата данни.

\begin{lstlisting}[caption=Пресмятания с данни в база данни, label=listing0127]
table %>% group_by(cut) %>% dplyr::summarize(AveragePrice=mean(price),AverageCarat=mean(carat))
# Source:   lazy query [?? x 3]
# Database: sqlite 3.22.0 [/Users/todorbalabanov/Desktop/diamonds.db]
  cut       AveragePrice AverageCarat
  <chr>            <dbl>        <dbl>
1 Fair             4359.        1.05 
2 Good             3929.        0.849
3 Ideal            3458.        0.703
4 Premium          4584.        0.892
5 Very Good        3982.        0.806
Warning messages:
1: Missing values are always removed in SQL.
Use `AVG(x, na.rm = TRUE)` to silence this warning 
2: Missing values are always removed in SQL.
Use `AVG(x, na.rm = TRUE)` to silence this warning
\end{lstlisting}

Важно е да се има предвид, че липсващите данни винаги се игнорират при работа с SQL данни (Листинг \ref{listing0127}).

\section{Пакетът purrr}

Пакетът purrr е създаден с цел изготвянето на стандартизиран начин за обхождане на списъци и вектори. В пакета са заимствани похвати от функционалното програмиране\index{функционално програмиране}. В широк смисъл това означава, че функциите не зависят от нищо друго, освен от входящите си аргументи.

\subsection{Фамилията функции map}

В основата на пакета purrr е функцията map. Целта ѝ е да приложи определена функция върху всеки елемент на списък (независимо елемент от елемент) и като резултат да върне списък със същата дължина\index{обхождане по елементи}. Поведението прилича на вече описаната функция lapply.

\begin{lstlisting}[caption=Прилагане на функцията map, label=listing0128]
library(purrr)

l1 <- list(m2=matrix(1:9,3), l2=1:5, m3=matrix(1:4,2), n1=2)

l1 %>% map( sum )
l1 %>% map(function(x) sum(x, na.rm=TRUE))
l1 %>% map(sum, na.rm=TRUE)
\end{lstlisting}

При липсващи стойности (NA), за да се извърши правилно пресмятането, на сумиращата функция трябва да се подаде na.rm=TRUE.

Функцията map винаги връща списък, като резултат, но не винаги това е желания краен ефект. Поради тази причина, в пакета purrr са реализирани цяла група map\_* функции (на мястото на * е върнатият тип). Функциите връщат стойност или, ако това не е възможно - грешка (Таб. \ref{table0004}). 

\begin{table}[h!]
\centering
\begin{tabular}{|l|r|} 
  \rowcolor{lightgray}
  \hline
  Функция & Тип на върнатата стойност \\ [0.1ex] 
  \hline\hline
  map & list \\
  \hline
  map\_int & integer \\
  \hline
  map\_dbl & numeric \\
  \hline
  map\_chr & character \\
  \hline
  map\_lgl & logical \\
  \hline
  map\_df & data.frame \\
  \hline
\end{tabular}
\caption{Фамилия функции map}
\label{table0004}
\end{table}

Всяка от изброените функции очаква да получи, като входен аргумент, вектор с дължина единица за всеки елемент. Ако това условие не е спазено, функцията завършва с грешка изпълнението си (Листинг \ref{listing0129}). 

\begin{lstlisting}[caption=Извиквания на map\, според тип на върнатата стойност, label=listing0129]
l1 %>% map_int(NROW)
m2 l2 m3 n1 
 3  5  2  1 
 
l1 %>% map_dbl(mean)
 m2  l2  m3  n1 
5.0 3.0 2.5 2.0 

l1 %>% map_chr(class)
       m2        l2        m3        n1 
 "matrix" "integer"  "matrix" "numeric" 

l1 %>% map_lgl(function(x) NROW(x) < 3)
   m2    l2    m3    n1 
FALSE FALSE  TRUE  TRUE 

list(3,4,1,5) %>% map( function(x){ data.frame(A=1:x,B=x:1) } )

list(3,4,1,5) %>% map_df( function(x){ data.frame(A=1:x,B=x:1) } )

l1 %>% map_if(is.matrix, function(x) x*2)

l1 %>% map_if(is.matrix, ~ .x*2)
\end{lstlisting}

За изграждането на data.frame списък, чрез помощна функция, може да се използва анонимна функция, а броят на редовете да се подаде през поточната операция. За да бъде резултатът оформен като един data.frame, то се използва функцията map\_df. При функцията map\_if модификация търпят само елементите, които отговарят на предварително поставеното условие. Вместо анонимна функция е възможно да се използва формула при извикването на map\_if.

\begin{lstlisting}[caption=Обхождане на data.frame, label=listing0130]
data(diamonds, package='ggplot2')

diamonds %>% map_dbl(mean)
       carat          cut        color      clarity        depth        table 
   0.7979397           NA           NA           NA   61.7494049   57.4571839 
       price            x            y            z 
3932.7997219    5.7311572    5.7345260    3.5387338 
Warning messages:
1: In mean.default(.x[[i]], ...) :
  argument is not numeric or logical: returning NA
2: In mean.default(.x[[i]], ...) :
  argument is not numeric or logical: returning NA
3: In mean.default(.x[[i]], ...) :
  argument is not numeric or logical: returning NA
\end{lstlisting}

Обхождането на data.frame обект е изключително лесно, тъй като по-същество той е съставен от списъци (Листинг \ref{listing0130}). При не числените колони резултатът е NA, тъй като за тях не може да се пресметне средна стойност.

\begin{lstlisting}[caption=Едновременно обхождане на два списъка, label=listing0131]
l3 <- list(m4=matrix(1:25,5), m5=matrix(1:16,2), l4=1:5)
l5 <- list(m6=matrix(1:25,5), m7=matrix(1:16,8), l6=15:1)

map2(l3, l5, function(x, y){NROW(x) + NROW(y)})
map2_int(l3, l5, function(x, y){NROW(x) + NROW(y)})
pmap(list(l3, l5), function(x, y){NROW(x) + NROW(y)})
\end{lstlisting}

За паралелното обхождане на два списъка, в пакета purrr са предложени функциите map2 и pmap (Листинг \ref{listing0131}).

\section*{Заключение}

Подходящата предварителна обработка на данните за извършване на статистически анализ е ключова стъпка от процеса. В практиката това често налага групиране по признаци, филтриране по зададен критерии или итеративно обхождане и манипулация по зададени условия. Доброто разбиране и ефективната предварителна обработка на данните води до ясни и разбираеми резултати в следствие на статистическия анализ.

