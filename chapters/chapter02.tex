\newpage
\chapter{Пакетна организация и основни операции в R}
\label{chapter02}

Най-голямата сила на продукта R се дължи на хилядите пакети\index{пакети} (софтуерни приставки), създадени от безброй потребители на продукта. Наличните пакети покриват цялата област на статистиката и статистическата обработка на данни. 

Под пакет се разбира софтуерна библиотека от предварително написан програмен кой, който има за цел да реши определена задача или група от задачи. Тъй като продуктът R е една отворена система е важно да се има предвид, че не всички пакети са с еднакво качество. Една част от пакетите са изключително професионално написани, устойчиви са на некоректно използване и имат добра база от поддържащи ги потребители. В същото време друга част от пакетите са създадени с голяма доза добри намерения, но работят бавно, дават дефекти или просто не вършат това за което са създадени. Голяма част от пакетите са написани от статистици за статистици и това може да доведе до някои странни въпроси при част от потребителите, особено при хора идващи от индустрията за производство на софтуер. 

Настоящото учебно помагало представя само най-основните пакети, достатъчни да бъде изложен материалът свързан с базовите познания по R. Опит да бъдат представени всички пакети е непосилен за едно издание, най-вече защото броят и видът на пакетите постоянно се променя. 

\section{Инсталиране на пакети}

Съществуват различни начини за инсталиране на пакети в R, но най-основният от тях е чрез команда в конзолата на пакета R. 

\begin{figure}[h!]
  \centering
  \includegraphics[width=1.0\linewidth]{pic0014}
  \caption{Команда за инсталиране на пакета coefplot}
\label{figure0014}
\end{figure}
\FloatBarrier

За да започне инсталирането на пакет (в случая coefplot) е достатъчно да се изпише командата от Фиг. \ref{figure0014}.

\begin{figure}[h!]
  \centering
  \includegraphics[width=1.0\linewidth]{pic0015}
  \caption{Избор на сървър за изтегляне на пакета}
\label{figure0015}
\end{figure}
\FloatBarrier

След което следва избор на сървър за изтегляне на пакета (Фиг. \ref{figure0015}). Разумна стратегия е да се избират сървъри, които териториално се намират в близост до мястото от което се работи. Това би осигурило малко по-голяма бързина на връзката в Глобалната мрежа. 

\begin{figure}[h!]
  \centering
  \includegraphics[width=1.0\linewidth]{pic0016}
  \caption{Зависимости между пакетите}
\label{figure0016}
\end{figure}
\FloatBarrier

Често срещан случай е един пакет да има функционална зависимост от други пакети (Фиг. \ref{figure0016}). В такава ситуация е необходимо всички нужни пакети също да бъдат инсталирани. Стратегията при разработка на пакети е те да бъдат предлагани в компилиран (бинарен) вид, но понякога най-новите версии са под формата на програмен код и тогава потребителят има възможност да избере между бинарната версия или версията с програмен код. 

\begin{figure}[h!]
  \centering
  \includegraphics[width=1.0\linewidth]{pic0017}
  \caption{Резултат от инсталацията на пекета}
\label{figure0017}
\end{figure}
\FloatBarrier

Инсталацията на пакета приключва с подробен листинг, съдържащ описание на извършените операции (Фиг. \ref{figure0017}). 

\begin{figure}[h!]
  \centering
  \includegraphics[width=1.0\linewidth]{pic0018}
  \caption{Зареждане на пакета coefplot}
\label{figure0018}
\end{figure}
\FloatBarrier

Дали пакетът е надлежно инсталиран може да се провери с командата require (Фиг. \ref{figure0018}), която зарежда пакета в паметта. 

Съществува възможност пакетите да се инсталират под формата на програмен код, директно от хранилищата за програмен код, но за тази цел са нужни подходящите компилатори (най-често C/C++ и Fortran), както и по-задълбочени умения по програмиране. В редки случаи се налага инсталиране на пакета от ZIP файл. При такава ситуация е важно предварително да бъдат инсталирани всички пакети от които инсталирания пакет зависи. 

Премахване на инсталирани пакети става с помощта на командата remove.packages на която се подава вектор с имената на пакетите, които трябва да бъдат премахнати.

\section{Зареждане на пакети}

За да бъдат използвани пакетите не е достатъчно те да бъдат инсталирани, но трябва с команда да бъдат включени в текущата сесия от изчисления. R предлага две команди за зареждане на пакети – library и require. И двете изпълняват едно и също нещо – зареждат пакета в общата памет. Разликата е, че require връща TRUE, ако зареждането е било успешно и FALSE при неуспех. Тази възможност е полезна в редките случаи, когато пакетът се зарежда от програмния текст на функция. Подобна практика не е препоръчителна, но R дава такава възможност. И двете функции получават като параметър името на пакета, със или без кавички. Пакетите се зареждат еднократно и остават налични през цялата сесия от изчисления или докато изрично не бъдат премахнати от общата памет. 

\begin{figure}[h!]
  \centering
  \includegraphics[width=1.0\linewidth]{pic0019}
  \caption{Премахване на пакета coefplot от общата памет}
\label{figure0019}
\end{figure}
\FloatBarrier

Премахването на пакет от общата памет става с командата detach (Фиг. \ref{figure0019}). Същественото при тази команда е, че преди името на пакета се записва думата package. 

Тъй като пакетите се разработват основно на доброволни начала не рядко се случва в различни пакети да има едноименни функции. При подобна колизия на имената решението е операцията за принадлежност – двойно двуеточие (::). Когато бъде използвана операцията за принадлежност дори може да не се зарежда пакетът към който принадлежи функцията. 

\section{Основни математически операции}

R позволява да се извършват сложни математически пресмятания, но също така може да се използва и за базови математически сметки. 

\begin{figure}[h!]
  \centering
  \includegraphics[width=1.0\linewidth]{pic0020}
  \caption{Примерни аритметични операции}
\label{figure0020}
\end{figure}
\FloatBarrier

Най-базовите математически операции са събирането, изваждането, умножението и делението. Тези операции се изпълняват в R както е показано на Фиг. \ref{figure0020}. Пресмятанията в R се състоят от операции и операнди. Когато няколко операции бъдат обединени, чрез операндите си, се получава математически израз. 

\begin{lstlisting}[caption=Събиране, label=listing0001]
1 + 1
\end{lstlisting}

В листинг \ref{listing0001} е демонстрирана операцията за събиране, която има два операнда. Когато става въпрос за математически операции, те имат серия свойства. Като най-съществена характеристика може да се отбележи броят на операндите. Събирането е класически пример за бинарна операция, тъй като има два операнда (ляв и десен). 

\begin{lstlisting}[caption=Унарен минус, label=listing0002]
-5
\end{lstlisting}

В гимназиалния курс по математика не се споменава наличието на унарен плюс, макар и да се учи за унарен минус (Листинг \ref{listing0002}). Унарният плюс и минус променят значението на операнда. В примера от листинг \ref{listing0002}, унарният минус променя значението на числото пето от положително към отрицателно. Тъй като унарният плюс не бил променил значението на операнда си, масовата практика е унарничт плюс да не се записва, нещо което не е възможно с унарния минус. Освен унарни и бинарни операции в някои езици (примерно C/C++, Java, C\#, PHP и други) съществува една единствена тернарна операция (?:), която има смисъла на условния оператор за преход if. 

Както бе споменато по-горе, комбинацията от няколко операции и техните операнди водят до съставянето на математически израз (Листинг \ref{listing0003}). 

\begin{lstlisting}[caption=Аритметичен израз с две събирания, label=listing0003]
2 + 2 + 2
\end{lstlisting}

Тъй като съвременните изчислителни машини са организирани по такъв начин, че процесорът да извършва само една математическа операция на един такт от пресмятането, става актуален въпросът коя от операциите ще бъде изпълнена първа и коя втора, при положение, че операциите са с еднакъв приоритет. Тъй като в англо-саксонската писмена система е прието да се пише и чете от ляво на дясно, то множество математически операции се изпълняват от ляво на дясно. Това се нарича лява асоциативност и събирането е точно от тази група операции.

\begin{lstlisting}[caption=Израз за каскадно присвояване, label=listing0004]
a = b = 2
\end{lstlisting}

В гимназиалната математика символът равно се използва за проверка на идентичността между двата операнда, но в компютърните езици символът за равенство има смисъл на операция за присвояване. Това означава, че десният операнд бива присвоен като стойност на левия операнд. При съставянето на математически израз с каскада от присвоявания няма друг вариант освен първо най-десният операнд да бъде изпълнен и едва накрая най-левият. Това се нарича дясна асоциативност и се използва при значително малък брой от математическите операции. 

\begin{lstlisting}[caption=Контекстна зависимост на опрациите, label=listing0005]
"abc" + "def"
2 + 2
\end{lstlisting}

Следващата важна характеристика на математическите операции е тяхната контекстна зависимост. В множество езици събирането на символни низове води до конкатенация (не и в R), докато събирането на числа води до резултат от числено събиране (Листинг \ref{listing0005}). 

\begin{lstlisting}[caption=Контекстна зависимост на опрацията за делене, label=listing0006]
5 / 3
5.0 / 3.0
\end{lstlisting}

В множество програмни езици (не и в R) операцията за делене е контекстно зависима (Листинг \ref{listing0006}). Когато и двата операнда са цели числа, резултатът е целочислено деление, а когато поне един от операндите е дробно число, то резултатът е дробно число. 

\begin{lstlisting}[caption=Приоритет на операциите, label=listing0007]
2 + 2 * 2
\end{lstlisting}

Когато в един математически израз участват повече от една операции с еднаква асоциативност от значение става приоритетът на всяка от тях. Най-често даваният пример е събирането и умножението (Листинг \ref{listing0007}). В случая първо се извършва умножението, тъй като е по-високо приоритетно, а едва след това събирането. 

\begin{lstlisting}[caption=Смяна на приоритета, label=listing0008]
(2 + 2) * 2
\end{lstlisting}

В компютърните езици кръглите скоби имат смисъла на операция за промяна на реда по който ще се извърши пресмятането с цел смяна на приоритета (Листинг \ref{listing0008}).

Последният съществен признак на операциите е в коя група попадат – аритметични, логически, побитови, за сравнение, за присвояване и други.

\section{Типове и променливи}

Повечето съвременни програмни езици организират работата с информация в групи от променливи. За разлика от строго типизираните езици в R не се задава тип на променливата. Типът на променливата неявно се определя от стойността, която е присвоена към нея. Това позволява да се присвояват дори обекти или функции. Това означава, че една и съща променлива може да съдържа данни от различни типове в различни моменти от времето. 

Променливата се появява в общата памет веднага след първата операция за присвояване, за което съществуват цяла група операции за присвояване (Листинг \ref{listing0009}). Променливите в R могат да съдържат в имената си латинските букви и арабските цифри, също символът точка (.) и подчертавка (\_). Имената на променливите не могат да започват с цифра или с подчертавка и са чувствителни към малки/големи букви. 

\begin{lstlisting}[caption=Операции за присвояване, label=listing0009]
a = 1
b <- 2
c = d = 3
e <- f <- 4
assign("g", 5)
a += 6
b -= 7
\end{lstlisting}

Стрелка на ляво (<-) служи за присвояване в R, но в повечето конвенционални програмни езици не присъства. 

\begin{lstlisting}[caption=Алтернативи за операцията присвояване, label=listing0010]
median(x = 1:10)
median(x <- 1:10)
\end{lstlisting}

Разликата между двете операции си проличава най-ясно при викането на функции с аргументи (Листинг \ref{listing0010}). В първия случай променливата x не остава в глобалната памет, а изчезва, докато при втория случай променливата x остава в глобалната памет, след извикването. 

Добра практика е за имената на променливите да се избират съществителни имена, а не еднобуквени имена или съкращения. 

\begin{lstlisting}[caption=Премахване на променливи от глобалната памет, label=listing0011]
rm( a )
rm( list=ls() )
\end{lstlisting}

Премахването на променлива от общата памет става с командата rm (Листинг \ref{listing0011}). За да се почисти цялата глобална памет се дава списък с всички променливи, налични в глобалната памет. Въпреки че R извиква Garbage Collector-а на определени интервал от време с командата gc() може да бъде отправена пряка заявка за освобождаване на ненужно заетата памет. 
