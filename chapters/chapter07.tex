\newpage
\chapter{Реорганизация на данните и обработка на символни низове}
\label{chapter07}

Освен манипулацията на данните, често се налага реорганизиране на начина по който те са структурирани. Понякога се налага транспониране или пък обединяване на няколко множества данни в едно общо. При обединяване на данни от различни източници не винаги данните имат една и съща структура, което допълнително усложнява задачата по преструктурирането им. 

\section{Обединяване на множества от данни}

Най-елементарният случай на обединение е при наличието на две множества от данни, които имат идентични колони или колоните съвпадат по брой и имена.

\begin{lstlisting}[caption=Обединяване на множества от данни, label=listing0132]
ds1 <- cbind(TV=c("BNT","bTV","Nova"),Channel=c(1,2,3),Rating=c(0.1,0.3,0.2))

ds2 <- data.frame(TV=c("HBO","VH1","MTV"),Channel=c(4,5,6),Rating=c(0.4,0.5,0.6),stringsAsFactors=FALSE)

ds <- rbind(ds1, ds2)
\end{lstlisting}

С такава ситуация се използват функциите cbind и rbind (Листинг \ref{listing0132}). С функцията cbind (свързване на колони) се формира мтарица, което изисква броя редове в съставляващите я списъци да е еднакъв. Функцията rbind (свързване на редове) обединява две множества при които броят редове може да се различава. 

В реалната практика, данните рядко биват събрани в подходяща за обединяване структура. В такива случаи често се налага използването на сливане по ключ, което е добре познато на хората работещи с езика SQL. За демонстрация на възможните сливания е използвано множеството данни предоставено от USAID Open Government инициативата (Листинг \ref{listing0133}). 

\begin{lstlisting}[caption=USAID множество от данни, label=listing0133]
setwd("~/Desktop")

download.file(url="https://github.com/TodorBalabanov/Statistical-Data-Processing-with-R/raw/master/data/aid.zip", destfile="aid.zip")

unzip("aid.zip", exdir="./")
\end{lstlisting}

След като бъде свален архивният файл, той трябва да бъде разархивиран. 

\begin{lstlisting}[caption=Зареждане USAID данните в R, label=listing0134]
library(stringr)

for(file in dir("./",pattern="\\.csv")) {
	name <- str_sub(string=file, start=12, end=18)

	data <- read.table(file=file.path(".", file), header=TRUE, sep=",", stringsAsFactors=FALSE)

	assign(x=name, value=data)
}
\end{lstlisting}

Тъй като данните са разпръснати в множество CVS файлове, на които имената са съставени по определен шаблон, то е удачно зареждането на информацията да бъде автоматизирано, като се прегледа цялата директория и бъдат прочетени всички налични в нея CSV файлове (Листинг \ref{listing0134}). Тъй като информацията от всеки прочетен файл трябва да се присвои на променлива, то е важно да се подберат подходящи имена за променливите. R е език в който малките и големите букви имат значение и поради тази причина трябва да се внимава с изписването на променливите. Един от вариантите за избор на имена е частична информация от основното име на файла. Чрез подходящо отрязване на символите (преди 12 и след 18) от името на файла се формира достатъчно разпознаваемо име за променлива. Следва прочитане на информацията и присвояването й на съответната променлива. 

\subsection{Функция merge}

\begin{lstlisting}[caption=Сливане на данни с merge, label=listing0135]
head(merge(x=Aid_90s, y=Aid_00s, by.x=c("Country.Name", "Program.Name"), by.y=c("Country.Name", "Program.Name")))
\end{lstlisting}

При сливане на данни в две data.frame структури може да се използва функцията merge (Листинг \ref{listing0135}). Чрез by.x се определя ключът в левия data.frame, а чрез by.y се определя ключът в десния data.frame. Определянето на различни колони, като ключ е най-значимата възможност на функцията merge. Трябва да се има предвид, че функцията merge е в базовия пакет на R и съответно може да бъде относително бавна при изпълнението си, в сравнение с други алтернативни функции. 

\begin{lstlisting}[caption=Сливане на данни при data.table, label=listing0136]
library(data.table)

dt90 <- data.table(Aid_90s, key=c("Country.Name", "Program.Name"))
dt00 <- data.table(Aid_00s, key=c("Country.Name", "Program.Name"))

dt0090 <- dt90[dt00]
\end{lstlisting}

Сливането на данни в пакета data.table използва малко по-различен синтаксис от този при функцията merge (Листинг \ref{listing0136}).

\subsection{Функция join}

Функцията join, от пакета plyr, работи по аналогичен начин, както функцията merge, но е с по-добро бързодействие. Недостатък на тази функция е, че всички колони, участващи в ключа, трябва да имат идентични имена (Листинг \ref{listing0137}). 

\begin{lstlisting}[caption=Сливане на данни с join, label=listing0137]
library(plyr)

head(join(x=Aid_90s, y=Aid_00s, by=c("Country.Name", "Program.Name")))
\end{lstlisting}

Функцията join има аргумент с който може да се окажат различните видове сливане (ляво, дясно, вътрешно и външно). За да се получи едно общо множество, чрез функцията Reduce може да се изпълнят множество сливания по двойки. 

\subsection{Транспониране на данните}

В практиката често се налага размяна на редовете с колоните и обратното. Въпреки че програмни пакети, като Microsoft Excel предлагат такава функционалност, понякога техните ограничения могат да създадат значителни затруднения. Примерно в Microsoft Excel е възприето, че редовете по брой значително превъзхождат възможностите за брой колони. При транспониране на големи обеми от данни е съвсем възможно броя колони да не достигнат и това да доведе до грешка при трансформацията. 

\section*{Заключение}

